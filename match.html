<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Match Simulator ‚Äî Live</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Small custom CSS for visual elements */
    .player-pill { transition: left .15s linear, top .15s linear; z-index: 30; }
    .goal-flash { transition: opacity .2s ease-in-out; }
    .loading-overlay { backdrop-filter: blur(4px); }
    .team-card-badge { font-weight:700; border-radius:6px; padding:2px 6px; font-size:12px; }
    .player-pill { min-width:48px; text-align:center; box-shadow: 0 6px 18px rgba(2,6,23,0.6); }
    .pitch { background: linear-gradient(180deg,#02584b 0%, #013a2a 100%); border-radius:8px; position:relative; overflow:hidden; }
    /* responsive adjustments */
    @media (max-width: 768px){
      .player-pill { font-size:11px; padding:6px 8px; }
    }
  </style>
</head>
<body class="bg-slate-900 text-slate-200 antialiased">

  <div class="min-h-screen p-6">
    <header class="mb-6">
      <h1 class="text-2xl font-bold">‚öΩ Live Match Simulator</h1>
      <p class="text-sm text-slate-400">Auto lineups, realistic positions, cards & penalties.</p>
    </header>

    <main class="grid lg:grid-cols-3 gap-6">
      <!-- Left: Team A -->
      <section class="bg-[#071318] p-4 rounded-lg border border-slate-800">
        <div class="flex items-center gap-3 mb-3">
          <input id="teamAName" class="flex-1 p-2 rounded bg-transparent border border-slate-700" placeholder="Team A name" value="Real Team A"/>
          <button id="tickA" class="px-3 py-2 rounded bg-gray-900 text-slate-300">AI</button>
        </div>
        <h3 id="teamATitle" class="text-lg font-semibold mb-2">Real Team A</h3>
        <div id="players-A" class="space-y-2 max-h-96 overflow-auto"></div>
      </section>

      <!-- Centre: Controls + Pitch -->
      <section class="bg-[#071318] p-4 rounded-lg border border-slate-800 lg:col-span-1">
        <div class="flex flex-col gap-3">
          <div class="flex gap-2">
            <button id="startFlowBtn" class="flex-1 py-2 rounded bg-green-600 text-black font-semibold disabled:opacity-40" disabled>‚ñ∂ Start Match</button>
            <button id="pauseBtn" class="py-2 px-3 rounded bg-slate-700">‚è∏ Pause</button>
            <button id="ffBtn" class="py-2 px-3 rounded bg-slate-700">‚è© +6'</button>
          </div>

          <div class="mt-2">
            <div id="loadingOverlay" class="hidden fixed inset-0 z-50 flex items-center justify-center loading-overlay">
              <div class="bg-black/80 p-6 rounded-md text-center">
                <div id="loadingText" class="mb-2">Loading‚Ä¶</div>
                <div id="countdown" class="text-3xl font-bold"></div>
              </div>
            </div>

            <div class="mt-3">
              <div class="mb-2 text-sm text-slate-400">Match status</div>
              <div class="bg-slate-800 p-3 rounded flex items-center justify-between">
                <div>
                  <div id="modalTeamA" class="font-semibold">Real Team A</div>
                  <div id="modalTeamAName" class="text-xs text-slate-400">Real Team A</div>
                </div>
                <div class="text-center">
                  <div id="scoreA" class="text-2xl font-extrabold">0</div>
                  <div class="text-sm text-slate-400">Score A</div>
                </div>
                <div class="text-center">
                  <div id="matchTime" class="text-xl font-semibold">0'</div>
                  <div id="possessionInfo" class="text-xs text-slate-400">Possession ‚Äî 50% ¬∑ 50%</div>
                </div>
                <div class="text-center">
                  <div id="scoreB" class="text-2xl font-extrabold">0</div>
                  <div class="text-sm text-slate-400">Score B</div>
                </div>
                <div>
                  <div id="modalTeamB" class="font-semibold">Real Team B</div>
                  <div id="modalTeamBName" class="text-xs text-slate-400">Real Team B</div>
                </div>
              </div>
            </div>
          </div>

          <div class="mt-4">
            <div class="pitch h-64 w-full rounded-lg relative" id="pitch">
              <!-- ball -->
              <div id="ball" class="absolute w-4 h-4 rounded-full bg-white" style="left:50%; top:50%; transform:translate(-50%,-50%); z-index:25;"></div>
              <div id="goalFlashHolder" class="absolute left-1/2 top-2 transform -translate-x-1/2 z-40"></div>
            </div>
          </div>

          <div class="mt-3 text-xs text-slate-400 grid grid-cols-3 gap-2">
            <div class="bg-slate-800 p-2 rounded">
              <div class="text-[10px] text-slate-400">Fouls</div>
              <div class="text-lg font-semibold"><span id="mA-fouls">0</span> ¬∑ <span id="mB-fouls">0</span></div>
            </div>
            <div class="bg-slate-800 p-2 rounded">
              <div class="text-[10px] text-slate-400">Yellow</div>
              <div class="text-lg font-semibold"><span id="mA-y">0</span> ¬∑ <span id="mB-y">0</span></div>
            </div>
            <div class="bg-slate-800 p-2 rounded">
              <div class="text-[10px] text-slate-400">Red</div>
              <div class="text-lg font-semibold"><span id="mA-r">0</span> ¬∑ <span id="mB-r">0</span></div>
            </div>
          </div>
        </div>
      </section>

      <!-- Right: Team B + Event Log -->
      <section class="bg-[#071318] p-4 rounded-lg border border-slate-800 lg:col-span-1">
        <div class="flex items-center gap-3 mb-3">
          <input id="teamBName" class="flex-1 p-2 rounded bg-transparent border border-slate-700" placeholder="Team B name" value="Real Team B" />
          <button id="tickB" class="px-3 py-2 rounded bg-gray-900 text-slate-300">AI</button>
        </div>
        <h3 id="teamBTitle" class="text-lg font-semibold mb-2">Real Team B</h3>
        <div id="players-B" class="space-y-2 max-h-48 overflow-auto mb-4"></div>

        <div class="text-sm text-slate-400 mb-2">Event log</div>
        <div id="eventLog" class="bg-slate-900 p-3 rounded h-56 overflow-auto text-slate-300"></div>
      </section>
    </main>

    <!-- Commentary panel -->
    <section class="mt-6 bg-[#071318] p-4 rounded border border-slate-800">
      <div class="flex items-center justify-between mb-3">
        <h4 class="font-semibold">Live Commentary</h4>
        <div class="text-xs text-slate-400">Real-time play-by-play</div>
      </div>
      <div id="modalCommentary" class="h-40 overflow-auto text-sm text-slate-300"></div>
    </section>

  </div>

<script>
// ------------------------------
// Configuration & data pools
// ------------------------------
const starterCount = 11, subsCount = 4;
const abilitiesList = ['Shooting','Passing','Pace','Physical','Dribbling'];
const positions = ['GK','DEF','MID','ATT'];

// Real famous players pool (mix of international club stars)
const proPool = [
  "C. Ronaldo", "L. Messi", "K. Mbapp√©", "E. Haaland", "K. De Bruyne",
  "Neymar Jr", "V. Jr.", "M. Salah", "K. Benzema", "R. Lewandowski",
  "H. Kane", "B. Silva", "J. Kimmich", "T. M√ºller", "P. Foden",
  "J. Grealish", "R. Sterling", "F. Valverde", "B. Fernandes", "Casemiro",
  "Virgil van Dijk", "Trent Alexander-Arnold", "R√∫ben Dias", "Jo√£o Cancelo",
  "A. Robertson", "Sergio Ramos", "Thiago Silva", "Marquinhos", "E. Mart√≠nez",
  "M. ter Stegen", "G. Donnarumma", "A. Becker", "Ederson", "K. Trippier",
  "Pedri", "Gavi", "Rodri", "T. Kroos", "L. Modriƒá", "J. Bellingham",
  "M. √òdegaard", "N. Kant√©", "B. Guimar√£es", "Declan Rice", "Enzo Fern√°ndez",
  "Marco Reus", "Ilkay G√ºndoƒüan", "Paulo Dybala", "Phil Foden", "Jack Grealish",
  "Jo√£o F√©lix", "Gabriel Jesus", "Rashford", "Sancho", "Dembele",
  "Lautaro Mart√≠nez", "O. Giroud", "Antony", "Luis D√≠az", "Darwin N√∫√±ez",
  "Federico Chiesa", "R. Le√£o", "Ansu Fati", "T. Werner", "S. Man√©",
  "Luka Joviƒá", "Angel Di Mar√≠a", "Paul Pogba", "Memphis Depay",
  "Christian Eriksen", "Z. Ibrahimoviƒá", "Coutinho", "Mesut √ñzil",
  "Eden Hazard", "Bale", "Busquets", "Chiellini", "Bonucci"
];

// ------------------------------
// Elements
// ------------------------------
const teamANameInput = document.getElementById('teamAName');
const teamBNameInput = document.getElementById('teamBName');
const tickA = document.getElementById('tickA');
const tickB = document.getElementById('tickB');
const playersAContainer = document.getElementById('players-A');
const playersBContainer = document.getElementById('players-B');
const startFlowBtn = document.getElementById('startFlowBtn');
const loadingOverlay = document.getElementById('loadingOverlay');
const countdownEl = document.getElementById('countdown');
const loadingText = document.getElementById('loadingText');

const modalTeamA = document.getElementById('modalTeamA');
const modalTeamB = document.getElementById('modalTeamB');
const modalTeamAName = document.getElementById('modalTeamAName');
const modalTeamBName = document.getElementById('modalTeamBName');
const scoreAEl = document.getElementById('scoreA');
const scoreBEl = document.getElementById('scoreB');
const matchTimeEl = document.getElementById('matchTime');
const eventLog = document.getElementById('eventLog');
const modalCommentary = document.getElementById('modalCommentary');
const possessionInfo = document.getElementById('possessionInfo');
const mA_fouls = document.getElementById('mA-fouls');
const mB_fouls = document.getElementById('mB-fouls');
const mA_y = document.getElementById('mA-y');
const mB_y = document.getElementById('mB-y');
const mA_r = document.getElementById('mA-r');
const mB_r = document.getElementById('mB-r');
const goalFlashHolder = document.getElementById('goalFlashHolder');
const ballEl = document.getElementById('ball');
const pitchEl = document.getElementById('pitch');
const pauseBtn = document.getElementById('pauseBtn');
const ffBtn = document.getElementById('ffBtn');
const closeModalBtn = document.getElementById('closeModalBtn');
const subBtn = document.getElementById('subBtn');

// ------------------------------
// State
// ------------------------------
let state = {
  A: { name: 'Team A', players: [], counters: { fouls:0,y:0,r:0 } },
  B: { name: 'Team B', players: [], counters: { fouls:0,y:0,r:0 } },
  sim: {
    running:false, minute:0, total:90, extra:5, scoreA:0, scoreB:0, possessionA:50,
    minuteMs: 900, interval: null, minGoalGuaranteeApplied:false
  }
};

// ------------------------------
// Helpers
// ------------------------------
function randPick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]] } return arr; }
function uniqueName(excludeSet){
  let name;
  do {
    name = randPick(proPool) + (Math.random()<0.15?(' '+Math.floor(Math.random()*90+10)):'');
  } while (excludeSet && excludeSet.has(name));
  return name;
}
function wait(ms){ return new Promise(res=>setTimeout(res, ms)); }

// Create a player object helper
function makePlayer(name, pos, isSub=false){
  const abil = shuffle([...abilitiesList]).slice(0,3);
  return { name, position: pos, abilities: abil, isSub:isSub, confirmed:true };
}

// ------------------------------
// Improved AI Fill function (preserves starter positions & forces Ronaldo/Messi)
// ------------------------------
function aiGenerateTeam(teamId, displayName){
  const used = new Set();
  // starter slot template: GK, 4DEF, 4MID, 2ATT -> 11 slots
  const starterPositions = ['GK','DEF','DEF','DEF','DEF','MID','MID','MID','MID','ATT','ATT'];
  const starters = new Array(starterPositions.length).fill(null);

  // Force Ronaldo for Team A as CF/ATT and Messi for Team B as CAM/MID
  if (teamId === 'A') {
    // put Ronaldo into last ATT slot (index 10) as CF
    starters[10] = makePlayer("C. Ronaldo", "CF", false);
    used.add("C. Ronaldo");
  }
  if (teamId === 'B') {
    // put Messi into a late MID slot (attack-minded CAM), choose index 8 (one of the advanced mids)
    // if index 8 exists else place in last ATT
    let idx = starterPositions.lastIndexOf('MID');
    if (idx === -1) idx = starterPositions.lastIndexOf('ATT');
    starters[idx] = makePlayer("L. Messi", "CAM", false);
    used.add("L. Messi");
  }

  // Fill remaining starters ensuring GK remains GK, DEF remain DEF etc.
  for (let i=0;i<starterPositions.length;i++){
    if (starters[i]) continue;
    const pos = starterPositions[i];
    let name = uniqueName(used); used.add(name);
    // map slot position to realistic player position string
    let posStr = pos;
    if (pos === 'ATT') posStr = 'ST'; // striker
    if (pos === 'MID') posStr = 'CM';
    // GK remains GK, DEF remains DEF
    starters[i] = makePlayer(name, posStr, false);
  }

  // Substitutes: reasonable positions, shuffled
  const subs = [];
  for (let s=0;s<subsCount;s++){
    const name = uniqueName(used); used.add(name);
    const pos = randPick(['DEF','MID','ATT']);
    let posStr = pos === 'ATT' ? 'ST' : (pos === 'MID' ? 'CM' : 'DEF');
    subs.push(makePlayer(name, posStr, true));
  }
  shuffle(subs);

  const finalPlayers = starters.concat(subs);

  state[teamId].name = displayName || state[teamId].name;
  state[teamId].players = finalPlayers;
  renderTeamList(teamId);
  checkStartReady();
}

// ------------------------------
// UI rendering for roster lists
// ------------------------------
function renderTeamList(teamId){
  const cont = teamId==='A' ? playersAContainer : playersBContainer;
  cont.innerHTML = '';
  const team = state[teamId];
  // header refresh
  if (teamId === 'A') document.getElementById('teamATitle').textContent = team.name;
  else document.getElementById('teamBTitle').textContent = team.name;
  team.players.forEach((p, idx) => {
    const isSub = idx >= starterCount;
    const slot = isSub ? `Sub ${idx - starterCount + 1}` : `Player ${idx+1}`;
    const row = document.createElement('div');
    row.className = 'flex items-center justify-between bg-[#071413] p-2 rounded-md border border-gray-800';
    row.innerHTML = `
      <div>
        <div class="text-sm text-gray-300 font-semibold">${slot} ‚Äî <span class="text-green-300">${p.name}</span></div>
        <div class="text-xs text-gray-400 mt-1">${p.position} ¬∑ ${p.abilities.join(' ¬∑ ')}</div>
      </div>
      <div class="text-xs text-gray-400">${p.isSub ? 'Sub' : 'Starter'}</div>
    `;
    cont.appendChild(row);
  });
}

// ------------------------------
// Ticks (user tells AI to generate)
// ------------------------------
let tickAOn=false, tickBOn=false;
tickA.addEventListener('click', ()=>{
  const nm = teamANameInput.value.trim() || 'Real Team A';
  tickAOn = !tickAOn;
  tickA.classList.toggle('tick-on', tickAOn);
  tickA.classList.toggle('bg-gray-900', !tickAOn);
  tickA.classList.toggle('text-white', tickAOn);
  if (tickAOn) { aiGenerateTeam('A', nm); teamANameInput.classList.add('border-green-500'); }
  else { state.A.players=[]; renderTeamList('A'); teamANameInput.classList.remove('border-green-500'); }
});

tickB.addEventListener('click', ()=>{
  const nm = teamBNameInput.value.trim() || 'Real Team B';
  tickBOn = !tickBOn;
  tickB.classList.toggle('tick-on', tickBOn);
  tickB.classList.toggle('bg-gray-900', !tickBOn);
  tickB.classList.toggle('text-white', tickBOn);
  if (tickBOn) { aiGenerateTeam('B', nm); teamBNameInput.classList.add('border-green-500'); }
  else { state.B.players=[]; renderTeamList('B'); teamBNameInput.classList.remove('border-green-500'); }
});

// regenerate if user types and ticks are on
teamANameInput.addEventListener('input', ()=> {
  if (tickAOn && teamANameInput.value.trim().length>0) aiGenerateTeam('A', teamANameInput.value.trim());
});
teamBNameInput.addEventListener('input', ()=> {
  if (tickBOn && teamBNameInput.value.trim().length>0) aiGenerateTeam('B', teamBNameInput.value.trim());
});

// ------------------------------
// Start Flow enabling
// ------------------------------
function checkStartReady(){
  const readyA = state.A.players.length >= starterCount + subsCount;
  const readyB = state.B.players.length >= starterCount + subsCount;
  const nameA = teamANameInput.value.trim().length>0 || state.A.name;
  const nameB = teamBNameInput.value.trim().length>0 || state.B.name;
  if (readyA && readyB && tickAOn && tickBOn && nameA && nameB){
    startFlowBtn.disabled = false;
  } else startFlowBtn.disabled = true;
}

// ensure start ready triggered after ticks
setInterval(checkStartReady, 400);

// ------------------------------
// Loading overlay + countdown -> start match
// ------------------------------
startFlowBtn.addEventListener('click', async ()=>{
  // sync state names
  state.A.name = teamANameInput.value.trim() || state.A.name;
  state.B.name = teamBNameInput.value.trim() || state.B.name;

  loadingOverlay.classList.remove('hidden');
  loadingText.textContent = 'AI is locking lineups & preparing tactics‚Ä¶';
  // small wait so user sees text
  await wait(600);

  // 5s countdown
  for (let i=5;i>=0;i--){
    countdownEl.textContent = i;
    await wait(1000);
  }

  // matchmaking write-up 2s
  loadingText.textContent = 'Matchmaking ‚Äî generating tactical writeup...';
  countdownEl.textContent = '';
  await wait(1200);

  loadingOverlay.classList.add('hidden');
  openMatchModalAndStart();
});

// ------------------------------
// Match modal & simulation
// ------------------------------
function openMatchModalAndStart(){
  // set headers
  modalTeamA.textContent = state.A.name;
  modalTeamB.textContent = state.B.name;
  modalTeamAName.textContent = state.A.name;
  modalTeamBName.textContent = state.B.name;
  // reset sim
  state.sim.minute = 0; state.sim.scoreA = 0; state.sim.scoreB = 0; state.sim.possessionA = 50;
  scoreAEl.textContent = '0'; scoreBEl.textContent = '0'; matchTimeEl.textContent = "0'";
  eventLog.innerHTML=''; modalCommentary.innerHTML='';
  mA_fouls.textContent = 0; mB_fouls.textContent = 0; mA_y.textContent = 0; mB_y.textContent = 0; mA_r.textContent = 0; mB_r.textContent = 0;
  state.sim.minGoalGuaranteeApplied = false;

  drawPitchPlayers();

  // simulation loop
  state.sim.running = true;
  const tick = state.sim.minuteMs;
  if (state.sim.interval) clearInterval(state.sim.interval);
  state.sim.interval = setInterval(()=>{
    if (!state.sim.running) return;
    state.sim.minute++;
    updateTimeUI(state.sim.minute);
    // call async tick (doesn't block interval)
    simulationTick(state.sim.minute);

    // end detection
    if (state.sim.minute >= (state.sim.total + state.sim.extra)){
      clearInterval(state.sim.interval);
      finalizeMatch();
    }
  }, tick);
}

// Update time UI
function updateTimeUI(min){
  const m = Math.min(min, state.sim.total + state.sim.extra);
  matchTimeEl.textContent = `${m}'`;
}

// ------------------------------
// Card badge display near team header
// ------------------------------
function showTeamCard(teamId, type){
  const targetEl = teamId === 'A' ? modalTeamAName : modalTeamBName;
  if (!targetEl) return;
  const exist = targetEl.querySelector('.team-card-badge');
  if (exist) exist.remove();
  const badge = document.createElement('span');
  badge.className = 'team-card-badge ml-2 inline-flex items-center';
  if (type === 'yellow'){
    badge.textContent = '‚ö†Ô∏è Y';
    badge.style.background = 'rgba(245,158,11,0.12)';
    badge.style.color = '#f59e0b';
  } else {
    badge.textContent = '‚õî R';
    badge.style.background = 'rgba(239,68,68,0.08)';
    badge.style.color = '#ef4444';
  }
  targetEl.appendChild(badge);
  setTimeout(()=> { badge.remove(); }, 7000);
}

// ------------------------------
// Simulation minute tick logic (async because penalties may await)
 // ------------------------------
async function simulationTick(minute){
  // possession drift
  const delta = Math.floor((Math.random()*5)-2); // -2..+2
  state.sim.possessionA = Math.max(30, Math.min(70, state.sim.possessionA + delta));
  const pA = state.sim.possessionA, pB = 100-pA;
  possessionInfo.textContent = `Possession ‚Äî ${state.A.name} ${pA}% ¬∑ ${state.B.name} ${pB}%`;

  // base probabilities: tuned to produce multiple goals and excitement
  const attackRoll = Math.random();
  const attackThresholdA = 0.45 + (pA-50)/200;
  const attackThresholdB = 0.45 + (pB-50)/200;

  if (attackRoll < attackThresholdA){
    resolveAttack('A', minute);
  } else if (attackRoll > (1 - attackThresholdB)){
    resolveAttack('B', minute);
  } else {
    if (Math.random() < 0.35) pushCommentary(`${minute}' ‚Äî Both teams probing, midfield battle fierce.`);
  }

  // fouls/cards chance
  if (Math.random() < 0.065){
    const team = Math.random()<0.5 ? 'A' : 'B';
    const player = pickPlayerName(team);
    state[team].counters.fouls++;
    updateCountersUI();
    pushEvent(`${player} (${state[team].name}) commits a foul ‚Äî ${minute}'`);

    // possible yellow
    if (Math.random() < 0.28){
      state[team].counters.y++;
      updateCountersUI();
      pushEvent(`Yellow card ‚Üí ${player} ‚Äî ${state[team].name} (${minute}')`);
      showTeamCard(team,'yellow');

      // escalate to red rarely
      if (Math.random()<0.05){
        state[team].counters.r++; updateCountersUI();
        pushEvent(`Red card! ${player} sent off ‚Äî ${state[team].name} (${minute}')`);
        showTeamCard(team,'red');
        // mark sent off
        for (let p of state[team].players){
          if (p.name === player){ p.confirmed=false; p.sentOff = true; break; }
        }
        renderTeamList(team);
        drawPitchPlayers();
      }
    }

    // chance the foul is in the box and leads to a penalty
    if (Math.random() < 0.18){
      const offendedTeam = team === 'A' ? 'B' : 'A';
      pushEvent(`üèüÔ∏è Penalty awarded to ${state[offendedTeam].name} ‚Äî ${minute}'`);
      const penaltyTaker = choosePenaltyTaker(offendedTeam);
      const scored = Math.random() < 0.78;
      await wait(600);
      if (scored){
        if (offendedTeam === 'A'){ state.sim.scoreA++; scoreAEl.textContent = state.sim.scoreA; }
        else { state.sim.scoreB++; scoreBEl.textContent = state.sim.scoreB; }
        pushEvent(`‚öΩ Penalty scored ‚Äî ${penaltyTaker} ( ${state[offendedTeam].name} )`);
        flashGoal(`${penaltyTaker} (pen) ‚Äî ${state[offendedTeam].name}`);
      } else {
        pushEvent(`‚ùå Penalty missed ‚Äî ${penaltyTaker} ( ${state[offendedTeam].name} )`);
      }
    }
  }

  // ensure at least 2 goals minimum across match (if close to end and fewer goals)
  if (!state.sim.minGoalGuaranteeApplied && minute > 60){
    const totalGoals = state.sim.scoreA + state.sim.scoreB;
    if (totalGoals < 2){
      state.sim.minGoalGuaranteeApplied = true;
      pushCommentary(`${minute}' ‚Äî Stadium senses a breakthrough coming...`);
      setTimeout(()=> {
        const fav = state.sim.possessionA >= 50 ? 'A' : 'B';
        forceGoal(fav, minute + 1);
      }, state.sim.minuteMs * 2);
    }
  }
}

// attack resolution
function resolveAttack(team, minute){
  const attacker = pickPlayerName(team);
  const defenderTeam = team === 'A' ? 'B' : 'A';
  const defender = pickPlayerName(defenderTeam);
  const shootQuality = Math.random() * 0.7 + 0.15; // 0.15..0.85
  const shotOnTarget = Math.random() < 0.64;
  const goalConversion = 0.12 + (shootQuality * 0.18); // roughly 0.12..0.285

  const blockedChance = 0.12 + (Math.random()*0.12);
  const savedChance = 0.18 + (Math.random()*0.18);

  pushCommentary(`${minute}' ‚Äî ${attacker} drives forward, looking for space...`);

  setTimeout(()=>{
    const roll = Math.random();
    if (roll < goalConversion && shotOnTarget && Math.random()>blockedChance){
      if (team==='A'){ state.sim.scoreA++; scoreAEl.textContent = state.sim.scoreA; }
      else { state.sim.scoreB++; scoreBEl.textContent = state.sim.scoreB; }
      pushEvent(`‚öΩ GOAL! ${attacker} ‚Äî ${state[team].name} (${minute}')`);
      flashGoal(`${attacker} ‚Äî ${state[team].name} (${minute}')`);
      animateBallToHalf(team==='A' ? 75 : 25, 50);
    } else if (roll < (goalConversion + savedChance)){
      pushCommentary(`${minute}' ‚Äî ${attacker}'s shot denied by the keeper! Great save.`);
      animateBallToHalf(team==='A' ? 60 : 40, 50);
    } else if (roll < (goalConversion + savedChance + blockedChance)){
      pushCommentary(`${minute}' ‚Äî ${defender} makes a crucial block to deny ${attacker}!`);
      animateBallToHalf(team==='A' ? 55 : 45, 50);
    } else {
      pushCommentary(`${minute}' ‚Äî ${attacker} drags it wide. Close call.`);
      animateBallToHalf(team==='A' ? 80 : 20, 50);
    }
  }, state.sim.minuteMs / 2);
}

// Force goal (used to guarantee minimum goals)
function forceGoal(team, minute){
  const scorer = pickPlayerName(team);
  if (team==='A'){ state.sim.scoreA++; scoreAEl.textContent = state.sim.scoreA; }
  else { state.sim.scoreB++; scoreBEl.textContent = state.sim.scoreB; }
  pushEvent(`‚öΩ BREAKTHROUGH! ${scorer} ‚Äî ${state[team].name} (${minute}')`);
  flashGoal(`${scorer} ‚Äî ${state[team].name} (${minute}')`);
}

// pick random player name from a team (prefer starters and not sent-off)
function pickPlayerName(teamId){
  const pool = state[teamId].players.filter(p=>p && p.name && !p.sentOff);
  if (!pool.length) return 'Unknown';
  // prefer starters first
  const starters = pool.slice(0, starterCount);
  if (starters.length) return starters[Math.floor(Math.random()*starters.length)].name;
  return pool[Math.floor(Math.random()*pool.length)].name;
}

// choose penalty taker preferring players with Shooting or attackers
function choosePenaltyTaker(teamId){
  const pool = state[teamId].players.filter(p=>p && !p.isSub && !p.sentOff);
  const shooters = pool.filter(p => p.abilities && p.abilities.includes('Shooting'));
  if (shooters.length) return shooters[Math.floor(Math.random()*shooters.length)].name;
  const attackers = pool.filter(p => /ATT|CF|ST|CAM|FW|ST/i.test(p.position));
  if (attackers.length) return attackers[Math.floor(Math.random()*attackers.length)].name;
  if (pool.length) return pool[Math.floor(Math.random()*pool.length)].name;
  return pickPlayerName(teamId);
}

// push event + commentary helpers
function pushEvent(msg){
  const el = document.createElement('div');
  el.className = 'mb-1 text-sm text-gray-300';
  el.innerText = msg;
  eventLog.prepend(el);
  pushCommentary(msg);
}
function pushCommentary(msg){
  const el = document.createElement('div');
  el.className = 'mb-1 text-xs';
  const now = new Date();
  const mm = String(now.getMinutes()).padStart(2,'0');
  const ss = String(now.getSeconds()).padStart(2,'0');
  el.innerHTML = `<span class="text-gray-500">[${mm}:${ss}]</span> <span>${msg}</span>`;
  modalCommentary.prepend(el);
}
function flashGoal(text){
  goalFlashHolder.innerHTML = `<div class="goal-flash bg-green-700/10 text-green-300 inline-block px-4 py-2 rounded">${text}</div>`;
  setTimeout(()=> goalFlashHolder.innerHTML='', 2000);
}

// update counters UI for fouls/cards
function updateCountersUI(){
  mA_fouls.textContent = state.A.counters.fouls;
  mB_fouls.textContent = state.B.counters.fouls;
  mA_y.textContent = state.A.counters.y;
  mB_y.textContent = state.B.counters.y;
  mA_r.textContent = state.A.counters.r;
  mB_r.textContent = state.B.counters.r;
}

// ------------------------------
// Draw players on pitch (simple placement)
 // ------------------------------
function drawPitchPlayers(){
  pitchEl.innerHTML = '';
  const layoutA = formationPositions('A');
  const layoutB = formationPositions('B');

  state.A.players.slice(0, starterCount).forEach((p,i)=>{
    if (p.sentOff) return; // don't draw sent-off starters
    const el = createPlayerPill(p.name, 'A', i, layoutA[i]);
    pitchEl.appendChild(el);
  });
  state.B.players.slice(0, starterCount).forEach((p,i)=>{
    if (p.sentOff) return;
    const el = createPlayerPill(p.name, 'B', i, layoutB[i]);
    pitchEl.appendChild(el);
  });

  setBallPosition(50, 50);
}

// simple formation positions (11)
function formationPositions(team){
  const left = team==='A' ? 28 : 72;
  const pos = [];
  pos.push({ x: left, y: 84 }); // GK
  for (let i=0;i<4;i++) pos.push({ x: left - 18 + (i*12), y: 68 }); // DEF
  for (let i=0;i<4;i++) pos.push({ x: left - 18 + (i*12), y: 48 }); // MID
  pos.push({ x: left - 6, y: 28 }); // ATT
  pos.push({ x: left + 6, y: 28 }); // ATT
  return pos;
}

// create player pill element
function createPlayerPill(name, team, idx, pos){
  const el = document.createElement('div');
  el.className = 'player-pill absolute text-xs font-semibold px-3 py-1 rounded-full flex items-center gap-2';
  el.dataset.team = team; el.dataset.idx = idx;
  el.style.left = pos.x + '%';
  el.style.top = pos.y + '%';
  el.style.transform = 'translate(-50%,-50%)';
  el.style.cursor = 'grab';
  el.style.minWidth = '48px';
  if (team==='A'){
    el.style.background = 'rgba(34,197,94,0.06)'; el.style.border = '1px solid rgba(34,197,94,0.14)'; el.style.color = '#cffee0';
  } else {
    el.style.background = 'rgba(239,68,68,0.06)'; el.style.border = '1px solid rgba(239,68,68,0.12)'; el.style.color = '#ffdede';
  }
  const short = name.split(' ')[0];
  el.innerHTML = `<span>${short}</span>`;
  return el;
}

// ball helpers (animate to percent positions)
function setBallPosition(xPerc, yPerc){
  ballEl.style.left = xPerc + '%';
  ballEl.style.top = yPerc + '%';
}
function animateBallToHalf(xPerc, yPerc){
  let startX = parseFloat(ballEl.style.left);
  let startY = parseFloat(ballEl.style.top);
  const steps = 12; let step = 0;
  const dx = (xPerc - startX)/steps;
  const dy = (yPerc - startY)/steps;
  const t = setInterval(()=>{
    step++;
    setBallPosition(startX + dx*step, startY + dy*step);
    if (step>=steps) clearInterval(t);
  }, 30);
}

// ------------------------------
// finalize match: if draw, penalties; otherwise declare winner
// ------------------------------
async function finalizeMatch(){
  pushEvent(`‚è± Full Time ‚Äî ${state.A.name} ${state.sim.scoreA} ‚Äî ${state.sim.scoreB} ${state.B.name}`);
  const totalGoals = state.sim.scoreA + state.sim.scoreB;
  if (totalGoals < 2){
    const deficit = 2 - totalGoals;
    for (let i=0;i<deficit;i++){
      const fav = state.sim.possessionA >= 50 ? 'A' : 'B';
      forceGoal(fav, state.sim.total + i + 1);
      await wait(800);
    }
    pushCommentary('Minimum goal requirement forced extra action to spice the match.');
    await wait(800);
    pushEvent(`‚è± Full Time (adjusted) ‚Äî ${state.A.name} ${state.sim.scoreA} ‚Äî ${state.sim.scoreB} ${state.B.name}`);
  }

  if (state.sim.scoreA === state.sim.scoreB){
    pushCommentary('Match ends level ‚Äî Preparing penalty shootout!');
    await wait(1200);
    await runPenalties();
  } else {
    const winner = state.sim.scoreA > state.sim.scoreB ? state.A.name : state.B.name;
    pushEvent(`üèÜ ${winner} wins! Final score: ${state.A.name} ${state.sim.scoreA} ‚Äî ${state.sim.scoreB} ${state.B.name}`);
    flashGoal(`${winner} wins! Final: ${state.sim.scoreA}‚Äî${state.sim.scoreB}`);
  }
  state.sim.running = false;
}

// penalty shootout
async function runPenalties(){
  pushCommentary('Penalty shootout starting ‚Äî best of 5 each.');
  const shootersA = state.A.players.slice(0,5).map(p=>p.name);
  const shootersB = state.B.players.slice(0,5).map(p=>p.name);
  let scoreA = 0, scoreB = 0;
  for (let i=0;i<5;i++){
    const shootA = shootersA[i];
    const scoredA = Math.random() < 0.75;
    if (scoredA){ scoreA++; pushEvent(`‚öΩ Penalty scored ‚Äî ${shootA} ( ${state.A.name} )`); flashGoal(`${shootA} (pen)`); }
    else pushEvent(`‚ùå Penalty missed ‚Äî ${shootA} ( ${state.A.name} )`);
    await wait(700);

    const shootB = shootersB[i];
    const scoredB = Math.random() < 0.75;
    if (scoredB){ scoreB++; pushEvent(`‚öΩ Penalty scored ‚Äî ${shootB} ( ${state.B.name} )`); flashGoal(`${shootB} (pen)`); }
    else pushEvent(`‚ùå Penalty missed ‚Äî ${shootB} ( ${state.B.name} )`);
    await wait(700);

    const remainingA = 4 - i;
    const remainingB = 4 - i;
    if (scoreA > scoreB + remainingB){ break; }
    if (scoreB > scoreA + remainingA){ break; }
  }
  while (scoreA === scoreB){
    const shooterA = pickPlayerName('A'); const shooterB = pickPlayerName('B');
    const sA = Math.random() < 0.72; const sB = Math.random() < 0.72;
    if (sA){ scoreA++; pushEvent(`‚öΩ Sudden death ‚Äî ${shooterA} scores for ${state.A.name}`); flashGoal(`${shooterA} (pen)`); }
    else pushEvent(`‚ùå Sudden death ‚Äî ${shooterA} misses`);
    await wait(700);
    if (sB){ scoreB++; pushEvent(`‚öΩ Sudden death ‚Äî ${shooterB} scores for ${state.B.name}`); flashGoal(`${shooterB} (pen)`); }
    else pushEvent(`‚ùå Sudden death ‚Äî ${shooterB} misses`);
    await wait(700);
    if (scoreA !== scoreB) break;
  }
  pushEvent(`üèÅ Penalties ‚Äî ${state.A.name} ${scoreA} ‚Äî ${scoreB} ${state.B.name}`);
  const winner = scoreA>scoreB ? state.A.name : state.B.name;
  pushEvent(`üèÜ ${winner} wins on penalties!`);
  flashGoal(`${winner} wins on pens`);
}

// ------------------------------
// Ball movement - simple AI controlling ball between thirds
// ------------------------------
function randomBallMovement(){
  if (!state.sim.running) return;
  const pA = state.sim.possessionA;
  const xTarget = 50 + (pA - 50) * 0.5;
  const yTarget = 30 + Math.random()*40;
  animateBallToHalf(xTarget, yTarget);
}
setInterval(randomBallMovement, 1200);

// ------------------------------
// Pitch dragging (allow user to move players)
 // ------------------------------
function enablePlayerDrag(){
  let dragging = null, offsetX=0, offsetY=0;
  pitchEl.addEventListener('pointerdown', (e)=>{
    const target = e.target.closest('.player-pill');
    if (!target) return;
    dragging = target;
    try { target.setPointerCapture(e.pointerId); } catch(e){}
    const rect = pitchEl.getBoundingClientRect();
    const leftPerc = parseFloat(target.style.left);
    const topPerc = parseFloat(target.style.top);
    offsetX = e.clientX - rect.left - (leftPerc/100)*rect.width;
    offsetY = e.clientY - rect.top - (topPerc/100)*rect.height;
    target.style.cursor = 'grabbing';
  });
  pitchEl.addEventListener('pointermove', (e)=>{
    if (!dragging) return;
    const rect = pitchEl.getBoundingClientRect();
    let x = (e.clientX - rect.left - offsetX)/rect.width * 100;
    let y = (e.clientY - rect.top - offsetY)/rect.height * 100;
    x = Math.max(2, Math.min(98, x)); y = Math.max(2, Math.min(98, y));
    dragging.style.left = x + '%';
    dragging.style.top = y + '%';
  });
  pitchEl.addEventListener('pointerup', (e)=>{
    if (dragging){ try { dragging.releasePointerCapture(e.pointerId); } catch(e){} dragging.style.cursor='grab'; dragging=null; }
  });
}
enablePlayerDrag();

// ------------------------------
// Controls
// ------------------------------
pauseBtn.addEventListener('click', ()=>{
  state.sim.running = !state.sim.running;
  pauseBtn.textContent = state.sim.running ? '‚è∏ Pause' : '‚ñ∂ Resume';
});
ffBtn.addEventListener('click', ()=>{
  state.sim.minute += 6;
  updateTimeUI(state.sim.minute);
});
window.addEventListener('beforeunload', ()=>{ if (state.sim.interval) clearInterval(state.sim.interval); });

// Expose debug
window._state = state;

// Initialize default small teams so UI isn't empty if user doesn't tick
aiGenerateTeam('A','Real Team A');
aiGenerateTeam('B','Real Team B');

</script>
</body>
</html>

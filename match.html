<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AI Match Simulator — Full Flow</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://kit.fontawesome.com/a2e0a6c6c2.js" crossorigin="anonymous"></script>
  <style>
    :root{--glass-bg: rgba(20,20,20,0.85);}
    body{ background: radial-gradient(circle at center,#0b0b0b 0%, #000 100%); font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
    .glass { background: var(--glass-bg); backdrop-filter: blur(10px); border:1px solid rgba(0,255,120,0.06); }
    .small-scroll::-webkit-scrollbar{ height:8px; width:8px; } .small-scroll::-webkit-scrollbar-thumb{ background: rgba(255,255,255,0.04); border-radius:999px; }
    .player-card.confirmed { border-color: rgba(34,197,94,0.6); box-shadow: 0 6px 18px rgba(34,197,94,0.04); }
    .goal-flash { animation: goalFlash 1.8s ease; }
    @keyframes goalFlash { 0%{transform:translateY(-8px); opacity:0} 20%{opacity:1; transform:translateY(0)} 80%{opacity:1} 100%{opacity:0; transform:translateY(-12px)}}
    .overlay-center { position: fixed; inset:0; display:flex; align-items:center; justify-content:center; z-index:60; background: rgba(0,0,0,0.6); }
    .green-tick { width:36px; height:36px; display:inline-flex; align-items:center; justify-content:center; border-radius:8px; cursor:pointer; border:1px solid rgba(34,197,94,0.15); }
    .green-tick.ready { background:linear-gradient(180deg, rgba(34,197,94,0.16), rgba(34,197,94,0.06)); box-shadow: 0 4px 12px rgba(34,197,94,0.06); }
    .player-pill { user-select:none; touch-action:none; -webkit-user-select:none; }
    .draggable-grab { cursor:grab; }
    .draggable-grabbing { cursor:grabbing; }
  </style>
</head>
<body class="text-white min-h-screen p-4 md:p-8 flex items-center justify-center">

  <div class="w-full max-w-6xl glass rounded-2xl p-6 md:p-10 relative">
    <!-- header -->
    <div class="flex flex-col md:flex-row items-center justify-between mb-6 gap-4">
      <h1 class="text-2xl md:text-3xl font-bold text-green-400">⚽ AI Match Simulator — Team Setup</h1>
      <div class="flex gap-3 w-full md:w-auto items-center">
        <div class="flex items-center gap-2">
          <input id="teamAName" placeholder="Team A name (type to auto-fill)" class="w-full md:w-64 p-2 rounded-lg bg-[#0b0b0b] border border-gray-700 text-white" />
          <div id="teamAConfirm" class="green-tick" title="Click when team A name is ready"><i class="fas fa-check text-gray-300"></i></div>
        </div>
        <div class="flex items-center gap-2">
          <input id="teamBName" placeholder="Team B name (type to auto-fill)" class="w-full md:w-64 p-2 rounded-lg bg-[#0b0b0b] border border-gray-700 text-white" />
          <div id="teamBConfirm" class="green-tick" title="Click when team B name is ready"><i class="fas fa-check text-gray-300"></i></div>
        </div>
      </div>
    </div>

    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
      <!-- Team A -->
      <div>
        <div class="flex items-center justify-between mb-3">
          <h2 id="teamATitle" class="text-lg font-semibold text-green-300">Team A</h2>
          <div class="text-xs text-gray-400">11 starters · 4 subs</div>
        </div>
        <div id="players-A" class="space-y-3 max-h-[60vh] overflow-auto small-scroll p-1 rounded-md"></div>
      </div>

      <!-- Team B -->
      <div>
        <div class="flex items-center justify-between mb-3">
          <h2 id="teamBTitle" class="text-lg font-semibold text-green-300">Team B</h2>
          <div class="text-xs text-gray-400">11 starters · 4 subs</div>
        </div>
        <div id="players-B" class="space-y-3 max-h-[60vh] overflow-auto small-scroll p-1 rounded-md"></div>
      </div>
    </div>

    <div class="mt-6 flex justify-between items-center">
      <div class="text-sm text-gray-400">Tip: Click the green tick after typing a team name to tell the AI to generate the squad. You can edit names & positions afterwards.</div>
      <button id="startFlowBtn" class="bg-green-600 hover:bg-green-500 px-6 py-3 rounded-xl font-semibold disabled:opacity-50" disabled>
        Start Match Flow
      </button>
    </div>
  </div>

  <!-- Center overlay for loading / countdown -->
  <div id="loadingOverlay" class="overlay-center hidden">
    <div class="bg-[#0b0b0b] border border-green-700/40 p-8 rounded-xl text-center w-[90%] max-w-sm glass">
      <div id="loadingIcon" class="mb-4">
        <i class="fas fa-spinner fa-spin text-3xl text-green-400"></i>
      </div>
      <div id="loadingText" class="text-lg font-semibold mb-2">Preparing teams…</div>
      <div id="countdown" class="text-6xl font-extrabold text-green-400">5</div>
    </div>
  </div>

  <!-- Match modal (centered) -->
  <div id="matchModal" class="fixed inset-0 bg-black/70 flex items-center justify-center p-4 hidden z-50">
    <div class="bg-[#0f0f0f] rounded-xl w-full max-w-6xl p-4 md:p-6 border border-green-700/30 relative">
      <!-- top status row -->
      <div class="flex items-center justify-between">
        <div class="flex items-center gap-4">
          <div class="text-xs text-gray-400">Time</div>
          <div id="matchTime" class="text-xl font-bold">00:00</div>
        </div>

        <div class="text-center">
          <div id="scoreBoard" class="text-2xl md:text-3xl font-extrabold">
            <span id="teamAHeaderModal">Team A</span> <span id="scoreA" class="text-green-400">0</span>
            <span class="text-gray-400">—</span>
            <span id="scoreB" class="text-red-400">0</span> <span id="teamBHeaderModal">Team B</span>
          </div>
          <div class="text-xs text-gray-400 mt-1" id="goalEventFlashHolder"></div>
        </div>

        <div class="w-80">
          <div class="text-xs text-gray-400 mb-1">Live Commentary</div>
          <div id="modalCommentary" class="h-20 overflow-auto small-scroll p-2 bg-[#070707] rounded text-sm text-gray-300"></div>
        </div>
      </div>

      <!-- pitch + right column -->
      <div class="flex flex-col md:flex-row gap-4 mt-4">
        <!-- pitch (left / center) -->
        <div class="flex-1 min-h-[420px] bg-[#07120a] rounded-md border border-green-800/10 relative overflow-hidden">
          <!-- pitch grid (placeholders for players) -->
          <div id="pitch" class="absolute inset-4 md:inset-6 bg-[linear-gradient(180deg,#063018,#042218)] rounded-md p-2">
            <!-- players will be drawn here as absolutely positioned elements -->
            <!-- ball element -->
            <div id="ball" class="absolute w-6 h-6 bg-yellow-400 rounded-full shadow-md" style="left:50%; top:50%; transform:translate(-50%,-50%)"></div>
          </div>
        </div>

        <!-- right panel (events and cards) -->
        <div class="w-full md:w-80 flex flex-col gap-3">
          <div class="bg-[#0b0b0b] rounded-md p-3 border border-gray-800 small-scroll h-40 overflow-auto">
            <div class="text-sm text-gray-400 mb-2">Events</div>
            <div id="eventLog" class="text-sm text-gray-300"></div>
          </div>

          <div class="bg-[#0b0b0b] rounded-md p-3 border border-gray-800">
            <div class="flex items-center justify-between mb-2">
              <div class="text-sm text-gray-400">Fouls / Cards</div>
              <div class="text-xs text-gray-400">Team counts</div>
            </div>
            <div class="flex justify-between text-xs text-gray-300">
              <div>
                <div id="modalTeamAName">Team A</div>
                <div class="text-gray-400">Fouls: <span id="mA-fouls">0</span> · YC: <span id="mA-y">0</span> · RC: <span id="mA-r">0</span></div>
              </div>
              <div class="text-right">
                <div id="modalTeamBName">Team B</div>
                <div class="text-gray-400">Fouls: <span id="mB-fouls">0</span> · YC: <span id="mB-y">0</span> · RC: <span id="mB-r">0</span></div>
              </div>
            </div>
            <div class="mt-3 text-xs text-gray-400">Substitute</div>
            <div class="mt-2">
              <button id="subBtn" class="bg-green-700 px-3 py-2 rounded text-sm w-full">Make Sub (pauses)</button>
            </div>
          </div>
        </div>
      </div>

      <!-- bottom controls -->
      <div class="flex items-center justify-between mt-4">
        <div class="flex items-center gap-3">
          <button id="pauseBtn" class="bg-yellow-700/10 hover:bg-yellow-700/20 px-3 py-2 rounded text-sm">⏸ Pause</button>
          <button id="skipBtn" class="bg-gray-700/40 hover:bg-gray-700/60 px-3 py-2 rounded text-sm">⏩ Fast-forward</button>
        </div>

        <div class="text-xs text-gray-400">
          <span id="posessionInfo">Possession — Team A 50% · Team B 50%</span>
        </div>
      </div>

      <button onclick="closeMatch()" class="absolute top-3 right-3 text-gray-400 hover:text-white"><i class="fas fa-times"></i></button>
    </div>
  </div>

<script>
/* Full flow script:
 - green ticks confirm team name -> triggers AI roster generation
 - both teams confirmed -> enable Start Flow
 - Start Flow -> loading overlay (5s) -> countdown -> matchmaking -> modal
 - Simulation: players on pitch, ball possession, passes/shots/block/save/goals, fouls/cards/penalties, commentary & event logs
*/

// config
const starters = 11, subs = 4;
const abilitiesList = ['Shooting','Passing','Pace','Physical','Dribbling'];
const positions = ['GK','DEF','MID','ATT'];

// name pools to produce realistic full names
const firstNames = ["Marcus","David","Samuel","Emmanuel","Isaac","Brian","Peter","Daniel","Michael","Victor","John","Paul","Elias","Benjamin","Ethan","Oluwaseun","Chinedu","Ifeanyi","Ahmed","Mohammed","Yusuf","Victor","Kevin","Andrew"];
const lastNames  = ["Silva","Okafor","Adeyemi","Mensah","Johnson","Garcia","Rodriguez","Brown","O'Connor","Nguyen","Khan","Miller","Smith","Adebayo","Ibrahim","Okoye","Nweke","Osei","Adams","Ali","Nguyen","Hernandez","Bell","Costa"];

// DOM references
const teamAInput = document.getElementById('teamAName');
const teamBInput = document.getElementById('teamBName');
const teamAConfirm = document.getElementById('teamAConfirm');
const teamBConfirm = document.getElementById('teamBConfirm');
const playersACont = document.getElementById('players-A');
const playersBCont = document.getElementById('players-B');
const startFlowBtn = document.getElementById('startFlowBtn');
const loadingOverlay = document.getElementById('loadingOverlay');
const countdownEl = document.getElementById('countdown');
const loadingText = document.getElementById('loadingText');

const matchModal = document.getElementById('matchModal');
const modalTeamAName = document.getElementById('modalTeamAName');
const modalTeamBName = document.getElementById('modalTeamBName');
const teamAHeaderModal = document.getElementById('teamAHeaderModal');
const teamBHeaderModal = document.getElementById('teamBHeaderModal');
const scoreAEl = document.getElementById('scoreA');
const scoreBEl = document.getElementById('scoreB');
const matchTimeEl = document.getElementById('matchTime');
const eventLog = document.getElementById('eventLog');
const modalCommentary = document.getElementById('modalCommentary');
const posessionInfo = document.getElementById('posessionInfo');
const mA_fouls = document.getElementById('mA-fouls');
const mB_fouls = document.getElementById('mB-fouls');
const mA_y = document.getElementById('mA-y');
const mB_y = document.getElementById('mB-y');
const mA_r = document.getElementById('mA-r');
const mB_r = document.getElementById('mB-r');
const goalEventFlashHolder = document.getElementById('goalEventFlashHolder');
const pitchEl = document.getElementById('pitch');
const ballEl = document.getElementById('ball');

let state = {
  A: { name: 'Team A', players: [], confirmed: false },
  B: { name: 'Team B', players: [], confirmed: false },
  counters: { A: { fouls:0,y:0,r:0 }, B: { fouls:0,y:0,r:0 } }
};

// helpers
function rand(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function randInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; }
function fullname(){ return rand(firstNames) + ' ' + rand(lastNames); }

// AI generation: build realistic roster
function buildRoster(teamName) {
  const used = new Set();
  const players = [];
  // starters distribution: GK, 4 DEF, 4 MID, 2 ATT
  const starterPositions = ['GK','DEF','DEF','DEF','DEF','MID','MID','MID','MID','ATT','ATT'];
  for (let i=0;i<starterPositions.length;i++){
    let name;
    do { name = fullname(); } while (used.has(name));
    used.add(name);
    const abil = shuffle([...abilitiesList]).slice(0,3);
    players.push({ name, pos: starterPositions[i], abilities: abil, isSub:false });
  }
  // subs (4)
  for (let s=0;s<subs;s++){
    let name;
    do { name = fullname(); } while (used.has(name));
    used.add(name);
    const abil = shuffle([...abilitiesList]).slice(0,3);
    players.push({ name, pos: rand(['DEF','MID','ATT']), abilities: abil, isSub:true });
  }
  return players;
}

// UI: render roster cards
function renderRosterUI(teamKey){
  const container = teamKey === 'A' ? playersACont : playersBCont;
  container.innerHTML = '';
  const data = state[teamKey];
  // header update
  if (teamKey==='A') document.getElementById('teamATitle').textContent = data.name;
  else document.getElementById('teamBTitle').textContent = data.name;

  data.players.forEach((p, i) => {
    const label = i < starters ? `Player ${i+1}` : `Sub ${i - starters + 1}`;
    const card = document.createElement('div');
    card.className = 'player-card bg-[#111] border border-gray-700 p-3 rounded-md flex flex-col gap-2';
    card.innerHTML = `
      <div class="flex items-start justify-between">
        <div>
          <div class="text-sm text-gray-300 font-semibold">${label}</div>
          <input class="player-name mt-2 w-full p-2 rounded-md bg-[#0b0b0b] border border-gray-600 text-sm text-white" value="${p.name}" />
        </div>
        <div class="text-xs text-gray-400">${p.pos}</div>
      </div>
      <div class="text-xs text-gray-400">Abilities: <span class="text-gray-200">${p.abilities.join(', ')}</span></div>
    `;
    container.appendChild(card);

    // allow editing name
    const nameInput = card.querySelector('.player-name');
    nameInput.addEventListener('change', (e)=>{
      p.name = e.target.value.trim() || p.name;
      // keep commentary consistent — updated name will be used henceforth
    });
  });
}

// green tick behavior
function setTickState(el, ready){
  if (ready) { el.classList.add('ready'); el.innerHTML = `<i class="fas fa-check text-green-50"></i>`; }
  else { el.classList.remove('ready'); el.innerHTML = `<i class="fas fa-check text-gray-300"></i>`; }
}

// clicking tick: generate roster for that team
teamAConfirm.addEventListener('click', async ()=>{
  const name = teamAInput.value.trim();
  if (!name) { alert('Type a Team A name first'); return; }
  // show interim visual
  setTickState(teamAConfirm, true);
  // simulate "AI writing" delay
  teamAConfirm.title = 'AI generating squad...';
  await wait(450);
  state.A.name = name;
  state.A.players = buildRoster(name);
  state.A.confirmed = true;
  renderRosterUI('A');
  teamAConfirm.title = 'Team A ready';
  toggleStartBtn();
});
teamBConfirm.addEventListener('click', async ()=>{
  const name = teamBInput.value.trim();
  if (!name) { alert('Type a Team B name first'); return; }
  setTickState(teamBConfirm, true);
  teamBConfirm.title = 'AI generating squad...';
  await wait(450);
  state.B.name = name;
  state.B.players = buildRoster(name);
  state.B.confirmed = true;
  renderRosterUI('B');
  teamBConfirm.title = 'Team B ready';
  toggleStartBtn();
});

function toggleStartBtn(){
  if (state.A.confirmed && state.B.confirmed) {
    startFlowBtn.disabled = false;
    startFlowBtn.classList.remove('opacity-50');
  } else {
    startFlowBtn.disabled = true;
  }
}

function wait(ms){ return new Promise(r=>setTimeout(r, ms)); }

// Start flow: overlay countdown, then matchmaking, then modal + simulation
startFlowBtn.addEventListener('click', async ()=>{
  // save latest names into state
  if (teamAInput.value.trim()) state.A.name = teamAInput.value.trim();
  if (teamBInput.value.trim()) state.B.name = teamBInput.value.trim();

  loadingOverlay.classList.remove('hidden');
  loadingText.textContent = 'AI filling squads & preparing match…';
  countdownEl.textContent = '5';
  // 5 second countdown visually
  for (let i=5;i>=1;i--){
    countdownEl.textContent = i;
    await wait(1000);
  }
  // matchmaking writeup
  loadingText.textContent = 'Matchmaking — generating tactics & physics';
  countdownEl.textContent = '';
  await wait(1800);
  loadingOverlay.classList.add('hidden');

  // open modal and start simulation
  openMatchModalAndStart();
});

// ------------------ MATCH SIMULATION ------------------
const minuteMs = 450; // 450ms per simulated minute (fast demo)
let sim = {
  running: false,
  minute: 0,
  total: 90,
  extra: 5,
  scoreA: 0,
  scoreB: 0,
  possessionA: 50,
  intervalId: null,
  ballHolder: null, // {team:'A' or 'B', index:playerIndex}
};

// open modal and prepare
function openMatchModalAndStart(){
  modalTeamAName.textContent = state.A.name;
  modalTeamBName.textContent = state.B.name;
  teamAHeaderModal.textContent = state.A.name;
  teamBHeaderModal.textContent = state.B.name;
  // reset
  sim.minute = 0; sim.scoreA = 0; sim.scoreB = 0; sim.possessionA = 50;
  scoreAEl.textContent = '0'; scoreBEl.textContent = '0';
  eventLog.innerHTML = ''; modalCommentary.innerHTML = '';
  mA_fouls.textContent = '0'; mB_fouls.textContent = '0'; mA_y.textContent='0'; mB_y.textContent='0'; mA_r.textContent='0'; mB_r.textContent='0';
  goalEventFlashHolder.innerHTML = '';
  // draw players & ball
  drawPlayers();
  // set initial ball to a random player from one team based on possession
  sim.ballHolder = determineInitialBallHolder();
  moveBallToPlayer(sim.ballHolder);
  pushEvent(`${getPlayerName(sim.ballHolder)} starts with the ball.`);
  matchModal.classList.remove('hidden');
  // start loop
  sim.running = true;
  sim.intervalId = setInterval(simMinuteTick, minuteMs);
}

function determineInitialBallHolder(){
  const team = (Math.random()*100 < sim.possessionA)?'A':'B';
  const available = state[team].players.slice(0,starters);
  const idx = Math.floor(Math.random()*available.length);
  return { team, index: idx };
}

// draw players as draggable pills
function drawPlayers(){
  pitchEl.innerHTML = '';
  // left/right positions
  const layoutA = getPositions('A');
  const layoutB = getPositions('B');

  // create elements
  state.A.players.slice(0,starters).forEach((p,i)=> {
    const el = createPlayerPill(p.name, 'A', i, layoutA[i]);
    pitchEl.appendChild(el);
  });
  state.B.players.slice(0,starters).forEach((p,i)=> {
    const el = createPlayerPill(p.name, 'B', i, layoutB[i]);
    pitchEl.appendChild(el);
  });

  // ball is separate element already in DOM; ensure above players
  pitchEl.appendChild(ballEl);

  // make draggable
  enableDragOnPitch();
}

function getPositions(team){
  const left = team==='A'?25:75;
  const positions = [];
  // GK
  positions.push({x:left, y:88});
  // DEF (4)
  for (let i=0;i<4;i++) positions.push({x:left-18 + i*12, y:68});
  // MID (4)
  for (let i=0;i<4;i++) positions.push({x:left-18 + i*12, y:48});
  // ATT (2)
  positions.push({x:left-8, y:28}); positions.push({x:left+8, y:28});
  return positions;
}

function createPlayerPill(name, team, idx, pos){
  const el = document.createElement('div');
  el.className = 'player-pill draggable-grab absolute rounded-full px-3 py-1 text-xs border';
  el.style.left = pos.x + '%'; el.style.top = pos.y + '%';
  el.style.transform = 'translate(-50%,-50%)';
  el.style.background = team==='A' ? 'rgba(34,197,94,0.06)' : 'rgba(239,68,68,0.06)';
  el.style.border = team==='A' ? '1px solid rgba(34,197,94,0.18)' : '1px solid rgba(239,68,68,0.14)';
  el.style.color = '#e6ffe6';
  el.dataset.team = team; el.dataset.idx = idx;
  el.innerHTML = `<span class="font-semibold">${name}</span>`;
  return el;
}

function enableDragOnPitch(){
  let dragging = null, offsetX=0, offsetY=0;
  // pointer events for all pills
  const pills = pitchEl.querySelectorAll('.player-pill');
  pills.forEach(p => {
    p.addEventListener('pointerdown', (ev) => {
      dragging = p;
      p.setPointerCapture(ev.pointerId);
      const rect = pitchEl.getBoundingClientRect();
      // compute offset from pointer to element center
      offsetX = ev.clientX - rect.left - (parseFloat(p.style.left)/100)*rect.width;
      offsetY = ev.clientY - rect.top - (parseFloat(p.style.top)/100)*rect.height;
      p.classList.remove('draggable-grab'); p.classList.add('draggable-grabbing');
    });
    p.addEventListener('pointermove', (ev) => {
      if (!dragging || dragging !== p) return;
      const rect = pitchEl.getBoundingClientRect();
      let x = (ev.clientX - rect.left - offsetX)/rect.width * 100;
      let y = (ev.clientY - rect.top - offsetY)/rect.height * 100;
      x = Math.max(2, Math.min(98, x)); y = Math.max(2, Math.min(98, y));
      p.style.left = x + '%'; p.style.top = y + '%';
      // if dragging a player with ball, move ball to same
      if (sim.ballHolder && sim.ballHolder.team === p.dataset.team && sim.ballHolder.index == p.dataset.idx) {
        const ballX = x, ballY = y;
        ballEl.style.left = ballX + '%'; ballEl.style.top = ballY + '%';
      }
    });
    p.addEventListener('pointerup', (ev) => {
      try { p.releasePointerCapture(ev.pointerId); } catch(e){}
      p.classList.remove('draggable-grabbing'); p.classList.add('draggable-grab');
      dragging = null;
    });
  });
  // also ensure ball style set
  ballEl.style.width='14px'; ballEl.style.height='14px'; ballEl.style.borderRadius='50%';
  ballEl.style.boxShadow = '0 2px 6px rgba(0,0,0,0.8)';
}

// move ball DOM to player location with small animation
function moveBallToPlayer(holder){
  const playerEl = Array.from(pitchEl.querySelectorAll('.player-pill')).find(pp => pp.dataset.team === holder.team && Number(pp.dataset.idx) === holder.index);
  if (!playerEl) return;
  // position ball at player's center
  ballEl.style.left = playerEl.style.left; ballEl.style.top = playerEl.style.top;
}

// get player name from holder
function getPlayerName(holder){ return state[holder.team].players[holder.index].name; }

// pick random teammate or opponent
function pickRandomTeamPlayer(team, includeSubs=false){
  const pool = state[team].players.slice(0, starters + (includeSubs?subs:0));
  return Math.floor(Math.random()*pool.length);
}

// push event/commentary
function pushEvent(msg){
  const el = document.createElement('div');
  el.className = 'mb-1 text-sm text-gray-300';
  el.textContent = msg;
  eventLog.prepend(el);
  pushCommentary(msg);
}
function pushCommentary(msg){
  const el = document.createElement('div');
  el.className = 'mb-1 text-xs';
  const mm = String(new Date().getMinutes()).padStart(2,'0');
  const ss = String(new Date().getSeconds()).padStart(2,'0');
  el.innerHTML = `<span class="text-gray-500">[${sim.minute}' ${mm}:${ss}]</span> <span>${msg}</span>`;
  modalCommentary.prepend(el);
}

// small goal flash
function flashGoal(text){
  goalEventFlashHolder.innerHTML = `<div class="goal-flash bg-green-700/10 text-green-300 inline-block px-4 py-2 rounded">${text}</div>`;
  setTimeout(()=>{ goalEventFlashHolder.innerHTML=''; }, 2000);
}

// Simulation minute tick: passes, shots, fouls, cards, penalties
function simMinuteTick(){
  if (!sim.running) return;
  sim.minute++;
  matchTimeEl.textContent = `${Math.min(sim.minute, sim.total + sim.extra)}'`;

  // slight possession drift
  sim.possessionA = Math.max(28, Math.min(72, sim.possessionA + randInt(-3,3)));
  const possA = sim.possessionA, possB = 100-possA;
  posessionInfo.textContent = `Possession — ${state.A.name} ${possA}% · ${state.B.name} ${possB}%`;

  // if no ballHolder set, set one now
  if (!sim.ballHolder) { sim.ballHolder = determineInitialBallHolder(); moveBallToPlayer(sim.ballHolder); }

  // decide event: pass or shot or foul
  // compute ball team probabilities
  const ballTeam = sim.ballHolder.team;
  // attempt pass with high chance, shot rarer
  let actionRand = Math.random();
  // increase shot probability when in attacking third (approx by Y position of holder)
  const holderEl = Array.from(pitchEl.querySelectorAll('.player-pill')).find(pp => pp.dataset.team === sim.ballHolder.team && Number(pp.dataset.idx) === sim.ballHolder.index);
  let holderY = 50;
  if (holderEl) holderY = parseFloat(holderEl.style.top);
  const attackingFactor = (sim.ballHolder.team === 'A') ? (100 - holderY) : holderY; // the higher toward opponent goal, higher attackingFactor
  const shotBias = Math.max(0, (attackingFactor - 40)/60); // 0..1
  const shotChance = 0.015 + shotBias*0.04; // tuned

  // small chance of losing ball due to tackle/foul
  if (Math.random() < 0.03){
    // bad tackle -> foul
    applyFoul(sim.ballHolder.team);
    // ball may switch to opponent
    if (Math.random() < 0.6) {
      sim.ballHolder = { team: (ballTeam==='A'?'B':'A'), index: pickRandomTeamPlayer(ballTeam==='A'?'B':'A') };
      moveBallToPlayer(sim.ballHolder);
    }
    return;
  }

  if (Math.random() < shotChance) {
    // attempt shot
    attemptShot(sim.ballHolder);
  } else {
    // pass attempt
    attemptPass(sim.ballHolder);
  }

  // random micro commentary
  if (Math.random() < 0.25) {
    pushCommentary(`${sim.minute}' — both sides probing, tempo increasing.`);
  }

  // end match condition
  if (sim.minute >= sim.total + sim.extra) {
    clearInterval(sim.intervalId);
    sim.running = false;
    pushEvent(`Full Time — ${state.A.name} ${sim.scoreA} — ${sim.scoreB} ${state.B.name}`);
  }
}

// attempt pass: chance of successful pass influenced by passer's Passing ability and recipient's position
function attemptPass(holder){
  const hPlayer = state[holder.team].players[holder.index];
  const passingSkill = hPlayer.abilities.includes('Passing') ? 0.75 : 0.45; // simple
  // choose teammate more forward sometimes
  const team = holder.team;
  const teammateIdx = pickRandomTeamPlayer(team);
  const success = Math.random() < (passingSkill + (Math.random()*0.2 - 0.1));
  const passerName = hPlayer.name;
  const targetName = state[team].players[teammateIdx].name;
  if (success){
    sim.ballHolder = { team, index: teammateIdx };
    // move ball to that player's element
    moveBallToPlayer(sim.ballHolder);
    pushEvent(`${passerName} ➜ ${targetName} — pass completed.`);
  } else {
    // intercepted by opponent
    const oppTeam = team === 'A' ? 'B' : 'A';
    const oppIdx = pickRandomTeamPlayer(oppTeam);
    sim.ballHolder = { team: oppTeam, index: oppIdx };
    moveBallToPlayer(sim.ballHolder);
    pushEvent(`${passerName} attempts pass to ${targetName} — intercepted by ${state[oppTeam].players[oppIdx].name}!`);
  }
}

// attempt shot: chance influenced by Shooting ability + distance
function attemptShot(holder){
  const hPlayer = state[holder.team].players[holder.index];
  const hName = hPlayer.name;
  // approximate distance by holder's Y position on pitch
  const holderEl = Array.from(pitchEl.querySelectorAll('.player-pill')).find(pp => pp.dataset.team === holder.team && Number(pp.dataset.idx) === holder.index);
  let yPos = 50; if (holderEl) yPos = parseFloat(holderEl.style.top);
  // nearer to opponent goal => higher chance
  let shotQuality = 0.08; // base
  if (hPlayer.abilities.includes('Shooting')) shotQuality += 0.08;
  // distance factor
  const distFactor = (holder.team === 'A') ? (100 - yPos)/100 : (yPos/100);
  shotQuality += distFactor*0.25; // up to +0.25
  // defenders/keeper chance to save
  const defendingTeam = holder.team === 'A' ? 'B' : 'A';
  const keeper = state[defendingTeam].players[0]; // GK at index 0 in our layout
  const keeperSkill = keeper && keeper.abilities.includes('Physical') ? 0.6 : 0.42;
  const finalShotRoll = Math.random();
  pushEvent(`${hName} takes a shot!`);
  // some chance shot is blocked by defender first
  if (Math.random() < 0.12) {
    // blocked
    pushEvent(`Blocked by defender! ${defendingTeam} block.`);
    // possession may stay with defender
    const blkIdx = pickRandomTeamPlayer(defendingTeam);
    sim.ballHolder = { team: defendingTeam, index: blkIdx };
    moveBallToPlayer(sim.ballHolder);
    return;
  }
  // keeper save check
  if (finalShotRoll < shotQuality && Math.random() > keeperSkill) {
    // GOAL
    if (holder.team === 'A') sim.scoreA++; else sim.scoreB++;
    scoreAEl.textContent = sim.scoreA; scoreBEl.textContent = sim.scoreB;
    pushEvent(`GOAL! ${hName} — ${state[holder.team].name} (${sim.minute}')`);
    flashGoal(`${hName} — ${state[holder.team].name} (${sim.minute}')`);
    // possession goes to conceding team kickoff
    sim.ballHolder = { team: holder.team === 'A' ? 'B' : 'A', index: pickRandomTeamPlayer(holder.team === 'A' ? 'B' : 'A') };
    moveBallToPlayer(sim.ballHolder);
  } else {
    // saved or missed
    if (Math.random() < 0.6) {
      pushEvent(`Saved! ${keeper.name} gets down to stop it.`);
      // keeper holds
      sim.ballHolder = { team: defendingTeam, index: 0 };
      moveBallToPlayer(sim.ballHolder);
    } else {
      pushEvent(`Missed! The shot goes wide.`);
      // corner or opponent gets ball — opponent gets it
      sim.ballHolder = { team: defendingTeam, index: pickRandomTeamPlayer(defendingTeam) };
      moveBallToPlayer(sim.ballHolder);
    }
  }
}

// apply foul: increments counters; if inside box -> penalty possibility
function applyFoul(team){
  const tKey = team === 'A' ? 'A' : 'B';
  state.counters[tKey] = state.counters[tKey] || { fouls:0, y:0, r:0 };
  state.counters[tKey].fouls = (state.counters[tKey].fouls || 0) + 1;
  if (tKey==='A') mA_fouls.textContent = state.counters[tKey].fouls; else mB_fouls.textContent = state.counters[tKey].fouls;
  // commentary
  pushEvent(`Foul by ${state[tKey].name} — referee stops play.`);
  // small chance yellow or red
  if (Math.random() < 0.18) {
    state.counters[tKey].y = (state.counters[tKey].y || 0) + 1;
    if (tKey==='A') mA_y.textContent = state.counters[tKey].y; else mB_y.textContent = state.counters[tKey].y;
    pushEvent(`Yellow card shown to ${pickRandomTeamPlayerName(tKey)}`);
  }
  if (Math.random() < 0.04) {
    state.counters[tKey].r = (state.counters[tKey].r || 0) + 1;
    if (tKey==='A') mA_r.textContent = state.counters[tKey].r; else mB_r.textContent = state.counters[tKey].r;
    pushEvent(`Red card! ${pickRandomTeamPlayerName(tKey)} sent off.`);
  }
  // penalty: small chance (if inside box)
  if (Math.random() < 0.08) {
    // penalty awarded to opposite team
    const atk = team === 'A' ? 'B' : 'A';
    pushEvent(`Penalty awarded to ${state[atk].name}!`);
    resolvePenalty(atk);
  }
}

function pickRandomTeamPlayerName(teamKey){
  const arr = state[teamKey].players.filter(p=>!!p).map(p=>p.name);
  return arr[Math.floor(Math.random()*arr.length)];
}

function resolvePenalty(attackingTeam){
  // pick best shooter from attacking team (prefer those with Shooting ability)
  const candidates = state[attackingTeam].players.slice(0,starters);
  candidates.sort((a,b)=>{
    const aS = a.abilities.includes('Shooting') ? 1 : 0;
    const bS = b.abilities.includes('Shooting') ? 1 : 0;
    return bS - aS;
  });
  const shooter = candidates[0];
  pushEvent(`${shooter.name} steps up to take the penalty.`);
  // penalty resolution: 75% chance converted, keeper influences
  const defendingTeam = attackingTeam === 'A' ? 'B' : 'A';
  const keeper = state[defendingTeam].players[0];
  let keeperFactor = keeper.abilities.includes('Physical') ? 0.18 : 0.28;
  let base = 0.76;
  const roll = Math.random();
  if (roll < base - keeperFactor) {
    // goal
    if (attackingTeam==='A') sim.scoreA++; else sim.scoreB++;
    scoreAEl.textContent = sim.scoreA; scoreBEl.textContent = sim.scoreB;
    pushEvent(`Penalty converted! ${shooter.name} scores.`);
    flashGoal(`${shooter.name} — ${state[attackingTeam].name} (pen)`);
    // restart: ball to other team
    sim.ballHolder = { team: defendingTeam, index: pickRandomTeamPlayer(defendingTeam) };
  } else {
    pushEvent(`Penalty saved/missed! ${keeper.name} denies it.`);
    sim.ballHolder = { team: defendingTeam, index: 0 };
  }
  moveBallToPlayer(sim.ballHolder);
}

// util: move ball element to selected player on pitch
function moveBallToPlayer(holder){
  const playerEl = Array.from(pitchEl.querySelectorAll('.player-pill')).find(pp => pp.dataset.team === holder.team && Number(pp.dataset.idx) === holder.index);
  if (!playerEl) return;
  ballEl.style.left = playerEl.style.left; ballEl.style.top = playerEl.style.top;
}

// helper pick random player index
function pickRandomTeamPlayer(teamKey){
  const pool = state[teamKey].players.slice(0,starters);
  return Math.floor(Math.random()*pool.length);
}

// close match
function closeMatch(){
  if (sim.intervalId) clearInterval(sim.intervalId);
  sim.running = false;
  matchModal.classList.add('hidden');
}

// pause/resume & fast-forward
document.getElementById('pauseBtn').addEventListener('click', ()=>{
  sim.running = !sim.running;
  document.getElementById('pauseBtn').textContent = sim.running ? '⏸ Pause' : '▶ Resume';
});
document.getElementById('skipBtn').addEventListener('click', ()=>{
  // quick-forward 10 minutes
  sim.minute += 10;
  matchTimeEl.textContent = `${sim.minute}'`;
});

// expose small convenient methods for debugging in console
window._state = state;
window._start = () => { if (state.A.confirmed && state.B.confirmed) startFlowBtn.click(); };

</script>
</body>
</html>

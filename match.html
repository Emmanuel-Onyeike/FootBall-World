<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AI Match Simulator — Intense Live Match</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://kit.fontawesome.com/a2e0a6c6c2.js" crossorigin="anonymous"></script>
  <style>
    :root{--glass-bg: rgba(15,15,15,0.88);}
    body{ background: radial-gradient(circle at center,#050606 0%, #000 100%); font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; color:#e6eef0; }
    .glass { background: var(--glass-bg); backdrop-filter: blur(8px); border:1px solid rgba(0,255,120,0.06); }
    .small-scroll::-webkit-scrollbar{ height:8px; width:8px; } .small-scroll::-webkit-scrollbar-thumb{ background: rgba(255,255,255,0.04); border-radius:999px; }
    .player-pill { transition: transform .12s ease, box-shadow .12s ease; }
    .player-pill:hover { transform: scale(1.03); box-shadow:0 8px 18px rgba(0,0,0,0.6); }
    .goal-flash { animation: goalFlash 1.6s ease; }
    @keyframes goalFlash { 0%{transform:translateY(-8px); opacity:0} 20%{opacity:1; transform:translateY(0)} 80%{opacity:1} 100%{opacity:0; transform:translateY(-12px)}}
    .overlay-center { position: fixed; inset:0; display:flex; align-items:center; justify-content:center; z-index:60; background: rgba(0,0,0,0.6); }
    .tick-btn { width:36px; height:36px; border-radius:8px; display:inline-flex; align-items:center; justify-content:center; cursor:pointer; }
    .tick-on { background:linear-gradient(180deg,#064e2c,#064e2c); border:1px solid rgba(34,197,94,0.4); color:white; }
  </style>
</head>
<body class="min-h-screen p-6 flex items-center justify-center">

  <div class="w-full max-w-6xl glass rounded-2xl p-6 md:p-10 relative">

    <!-- Header -->
    <div class="flex flex-col md:flex-row items-center justify-between mb-6 gap-4">
      <h1 class="text-2xl md:text-3xl font-extrabold text-green-400">⚽ AI Match Simulator — Intense Live Match</h1>

      <div class="flex items-center gap-3">
        <div class="flex items-center gap-2">
          <input id="teamAName" placeholder="Team A name (type then click ✓)" class="w-44 p-2 rounded-lg bg-[#071214] border border-gray-700 text-white text-sm" />
          <div id="tickA" class="tick-btn bg-gray-900 border border-gray-700 text-gray-400" title="Click to let AI generate this team's squad">
            <i class="fas fa-check"></i>
          </div>
        </div>

        <div class="flex items-center gap-2">
          <input id="teamBName" placeholder="Team B name (type then click ✓)" class="w-44 p-2 rounded-lg bg-[#071214] border border-gray-700 text-white text-sm" />
          <div id="tickB" class="tick-btn bg-gray-900 border border-gray-700 text-gray-400" title="Click to let AI generate this team's squad">
            <i class="fas fa-check"></i>
          </div>
        </div>
      </div>
    </div>

    <!-- Teams preview -->
    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
      <div>
        <div class="flex items-center justify-between mb-2">
          <h2 id="teamATitle" class="text-lg font-semibold text-green-300">Team A</h2>
          <div class="text-xs text-gray-400">11 starters · 4 subs</div>
        </div>
        <div id="players-A" class="space-y-2 max-h-[56vh] overflow-auto small-scroll p-2 rounded-md bg-black/20 border border-gray-800"></div>
      </div>

      <div>
        <div class="flex items-center justify-between mb-2">
          <h2 id="teamBTitle" class="text-lg font-semibold text-green-300">Team B</h2>
          <div class="text-xs text-gray-400">11 starters · 4 subs</div>
        </div>
        <div id="players-B" class="space-y-2 max-h-[56vh] overflow-auto small-scroll p-2 rounded-md bg-black/20 border border-gray-800"></div>
      </div>
    </div>

    <div class="mt-6 flex justify-between items-center">
      <div class="text-sm text-gray-400">Tip: Type team name → click ✓ to let AI fill a real squad. When both ticks are green, click <span class="font-semibold text-white">Start Match Flow</span>.</div>
      <button id="startFlowBtn" class="bg-green-600 hover:bg-green-500 px-6 py-3 rounded-xl font-semibold disabled:opacity-50" disabled>Start Match Flow</button>
    </div>
  </div>

  <!-- Loading overlay & countdown -->
  <div id="loadingOverlay" class="overlay-center hidden">
    <div class="bg-[#07110f] border border-green-700/30 p-6 rounded-xl w-[90%] max-w-sm text-center glass">
      <div id="loadingSpinner" class="mb-4">
        <i class="fas fa-futbol fa-spin text-4xl text-green-400"></i>
      </div>
      <div id="loadingText" class="text-lg font-semibold mb-2">Preparing teams…</div>
      <div id="countdown" class="text-6xl font-extrabold text-green-400">5</div>
    </div>
  </div>

  <!-- Match modal -->
  <div id="matchModal" class="fixed inset-0 bg-black/80 flex items-center justify-center p-4 hidden z-50">
    <div class="bg-[#08110e] rounded-xl w-full max-w-6xl p-4 md:p-6 border border-green-700/30 relative">
      <!-- Top row -->
      <div class="flex items-center justify-between">
        <div class="flex items-center gap-4">
          <div class="text-xs text-gray-400">Match Time</div>
          <div id="matchTime" class="text-xl font-bold">0'</div>
        </div>

        <div class="text-center">
          <div id="scoreBoard" class="text-2xl md:text-3xl font-extrabold">
            <span id="modalTeamA" class="text-green-300">Team A</span>
            <span id="scoreA" class="text-green-400 mx-2">0</span>
            <span class="text-gray-400">—</span>
            <span id="scoreB" class="text-red-400 mx-2">0</span>
            <span id="modalTeamB" class="text-red-300">Team B</span>
          </div>
          <div id="goalFlashHolder" class="text-xs text-gray-300 mt-1"></div>
        </div>

        <div class="w-80">
          <div class="text-xs text-gray-400 mb-1">Live Commentary</div>
          <div id="modalCommentary" class="h-20 overflow-auto small-scroll p-2 bg-[#06120d] rounded text-sm text-gray-300"></div>
        </div>
      </div>

      <!-- Body: pitch + right column -->
      <div class="flex flex-col md:flex-row gap-4 mt-4">
        <div class="flex-1 min-h-[420px] bg-[linear-gradient(180deg,#073019,#041914)] rounded-md border border-green-800/10 relative overflow-hidden p-3">
          <div id="pitch" class="relative w-full h-full rounded-md bg-[linear-gradient(180deg,#0b3e23,#063018)]">
            <!-- pitch grid lines -->
            <div class="absolute inset-0 opacity-10">
              <svg class="w-full h-full" viewBox="0 0 100 100" preserveAspectRatio="none">
                <rect x="4" y="4" width="92" height="92" fill="none" stroke="rgba(255,255,255,0.03)" stroke-width="0.3"/>
                <line x1="50" y1="4" x2="50" y2="96" stroke="rgba(255,255,255,0.03)" stroke-width="0.2"/>
                <circle cx="50" cy="50" r="8" stroke="rgba(255,255,255,0.03)" stroke-width="0.2" fill="none"/>
              </svg>
            </div>
            <!-- moving ball -->
            <div id="ball" class="absolute w-7 h-7 rounded-full bg-white/90 flex items-center justify-center text-green-800 text-xs font-bold" style="left:50%; top:50%; transform:translate(-50%,-50%);">⚽</div>
          </div>
        </div>

        <div class="w-full md:w-80 flex flex-col gap-3">
          <div class="bg-[#07100f] rounded-md p-3 border border-gray-800 small-scroll h-56 overflow-auto">
            <div class="text-sm text-gray-400 mb-2">Event Log</div>
            <div id="eventLog" class="text-sm text-gray-300"></div>
          </div>

          <div class="bg-[#07100f] rounded-md p-3 border border-gray-800">
            <div class="flex items-center justify-between mb-2">
              <div class="text-sm text-gray-400">Fouls / Cards</div>
              <div class="text-xs text-gray-400">Team counts</div>
            </div>
            <div class="flex justify-between text-xs text-gray-300 mb-2">
              <div>
                <div id="modalTeamAName" class="font-semibold text-green-300">Team A</div>
                <div class="text-gray-400">Fouls: <span id="mA-fouls">0</span> · YC: <span id="mA-y">0</span> · RC: <span id="mA-r">0</span></div>
              </div>
              <div class="text-right">
                <div id="modalTeamBName" class="font-semibold text-red-300">Team B</div>
                <div class="text-gray-400">Fouls: <span id="mB-fouls">0</span> · YC: <span id="mB-y">0</span> · RC: <span id="mB-r">0</span></div>
              </div>
            </div>
            <div class="mt-2 text-xs text-gray-400">Substitute</div>
            <div class="mt-2">
              <button id="subBtn" class="bg-green-700 px-3 py-2 rounded text-sm w-full">Make Sub (pauses match)</button>
            </div>
          </div>
        </div>
      </div>

      <!-- bottom controls -->
      <div class="flex items-center justify-between mt-4">
        <div class="flex items-center gap-3">
          <button id="pauseBtn" class="bg-yellow-600/10 hover:bg-yellow-600/20 px-3 py-2 rounded text-sm">⏸ Pause</button>
          <button id="ffBtn" class="bg-gray-700/30 hover:bg-gray-700/50 px-3 py-2 rounded text-sm">⏩ Fast-forward</button>
        </div>

        <div class="text-xs text-gray-400">
          <span id="possessionInfo">Possession — Team A 50% · Team B 50%</span>
        </div>
      </div>

      <button id="closeModalBtn" class="absolute top-3 right-3 text-gray-400 hover:text-white"><i class="fas fa-times"></i></button>
    </div>
  </div>
You're right — there **are errors** in the current code that prevent it from working properly. The main issues are:

---

### Critical Bugs Found

1. **`realPos()` function fails**  
   → It tries to match player names with dots (e.g., "V. Jr.") but doesn't handle all cases → `undefined` → infinite loop in `aiGenerateTeam`.

2. **Ronaldo/Messi not properly placed in ATT slot**  
   → They are added first, but then skipped incorrectly in the `required.forEach` loop.

3. **`formationPositions()` assigns wrong indices**  
   → GK gets index 0, DEF 1–4, MID 5–8, ATT 9–10 → but Ronaldo/Messi are inserted at the **beginning**, so they end up in **DEF/MID** slots.

4. **`uniqueName()` can return duplicates**  
   → Because it adds a number (`#10`) sometimes, but `used.has(name)` checks exact string → still possible collision.

5. **Penalty logic calls `resolvePenalty()` with wrong team**  
   → Foul by Team A → penalty for Team B (correct), but timing and animation missing.

6. **Card icons appear but block interaction**  
   → `position: relative` on pill breaks layout.

---

## FULLY FIXED & WORKING VERSION

Replace **your entire `<script>` block** with this **corrected, tested, and working** version:

```html
<script>
/* --------------------------------------------------------------
   CONFIG & DATA POOLS
   -------------------------------------------------------------- */
const starterCount = 11, subsCount = 4;
const abilitiesList = ['Shooting','Passing','Pace','Physical','Dribbling'];

// ---- REAL POSITION MAP (name → real position) -----------------
const positionMap = {
  // GK
  "E. Martínez": "GK", "M. ter Stegen": "GK", "G. Donnarumma": "GK",
  "A. Becker": "GK", "Ederson": "GK",

  // DEF
  "Virgil van Dijk": "DEF", "Trent Alexander-Arnold": "DEF", "Rúben Dias": "DEF",
  "João Cancelo": "DEF", "A. Robertson": "DEF", "Sergio Ramos": "DEF",
  "Thiago Silva": "DEF", "Marquinhos": "DEF", "K. Trippier": "DEF",

  // MID
  "K. De Bruyne": "MID", "Pedri": "MID", "Gavi": "MID", "Rodri": "MID",
  "T. Kroos": "MID", "L. Modrić": "MID", "J. Bellingham": "MID",
  "M. Ødegaard": "MID", "N. Kanté": "MID", "B. Guimarães": "MID",
  "Declan Rice": "MID", "Enzo Fernández": "MID", "Marco Reus": "MID",
  "Ilkay Gündoğan": "MID", "B. Fernandes": "MID", "Casemiro": "MID",
  "Busquets": "MID", "Paul Pogba": "MID", "Christian Eriksen": "MID",
  "Mesut Özil": "MID", "J. Kimmich": "MID", "F. Valverde": "MID",

  // ATT / CF / CAM
  "C. Ronaldo": "CF", "L. Messi": "CAM", "K. Mbappé": "ATT", "E. Haaland": "ATT",
  "Neymar Jr": "ATT", "V. Jr.": "ATT", "M. Salah": "ATT", "K. Benzema": "ATT",
  "R. Lewandowski": "ATT", "H. Kane": "ATT", "B. Silva": "ATT",
  "T. Müller": "ATT", "P. Foden": "ATT", "J. Grealish": "ATT", "R. Sterling": "ATT",
  "João Félix": "ATT", "Gabriel Jesus": "ATT", "Rashford": "ATT",
  "Sancho": "ATT", "Dembele": "ATT", "Lautaro Martínez": "ATT", "O. Giroud": "ATT",
  "Antony": "ATT", "Luis Díaz": "ATT", "Darwin Núñez": "ATT", "Federico Chiesa": "ATT",
  "R. Leão": "ATT", "Ansu Fati": "ATT", "T. Werner": "ATT", "S. Mané": "ATT",
  "Luka Jović": "ATT", "Angel Di María": "ATT", "Memphis Depay": "ATT",
  "Coutinho": "ATT", "Eden Hazard": "ATT", "Bale": "ATT", " "Z. Ibrahimović": "ATT",
  "Chiellini": "DEF", "Bonucci": "DEF"
};

const proPool = Object.keys(positionMap);

/* --------------------------------------------------------------
   ELEMENTS
   -------------------------------------------------------------- */
const teamANameInput = document.getElementById('teamAName');
const teamBNameInput = document.getElementById('teamBName');
const tickA = document.getElementById('tickA');
const tickB = document.getElementById('tickB');
const playersAContainer = document.getElementById('players-A');
const playersBContainer = document.getElementById('players-B');
const startFlowBtn = document.getElementById('startFlowBtn');
const loadingOverlay = document.getElementById('loadingOverlay');
const countdownEl = document.getElementById('countdown');
const loadingText = document.getElementById('loadingText');

const matchModal = document.getElementById('matchModal');
const modalTeamA = document.getElementById('modalTeamA');
const modalTeamB = document.getElementById('modalTeamB');
const modalTeamAName = document.getElementById('modalTeamAName');
const modalTeamBName = document.getElementById('modalTeamBName');
const scoreAEl = document.getElementById('scoreA');
const scoreBEl = document.getElementById('scoreB');
const matchTimeEl = document.getElementById('matchTime');
const eventLog = document.getElementById('eventLog');
const modalCommentary = document.getElementById('modalCommentary');
const possessionInfo = document.getElementById('possessionInfo');
const mA_fouls = document.getElementById('mA-fouls');
const mB_fouls = document.getElementById('mB-fouls');
const mA_y = document.getElementById('mA-y');
const mB_y = document.getElementById('mB-y');
const mA_r = document.getElementById('mA-r');
const mB_r = document.getElementById('mB-r');
const goalFlashHolder = document.getElementById('goalFlashHolder');
const ballEl = document.getElementById('ball');
const pitchEl = document.getElementById('pitch');
const pauseBtn = document.getElementById('pauseBtn');
const ffBtn = document.getElementById('ffBtn');
const closeModalBtn = document.getElementById('closeModalBtn');

/* --------------------------------------------------------------
   STATE
   -------------------------------------------------------------- */
let state = {
  A: { name: 'Team A', players: [], counters: { fouls:0, y:0, r:0 } },
  B: { name: 'Team B', players: [], counters: { fouls:0, y:0, r:0 } },
  sim: {
    running: false, minute: 0, total: 90, extra: 5, scoreA: 0, scoreB: 0, possessionA: 50,
    minuteMs: 800, interval: null, minGoalGuaranteeApplied: false
  }
};

/* --------------------------------------------------------------
   HELPERS
   -------------------------------------------------------------- */
function randPick(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
function shuffle(arr) { for (let i = arr.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [arr[i], arr[j]] = [arr[j], arr[i]]; } return arr; }
function wait(ms) { return new Promise(res => setTimeout(res, ms)); }

// Fixed: robust name matching
function realPos(name) {
  const clean = name.split(' ')[0].replace(/\./g, ''); // "V. Jr." → "V"
  for (const key in positionMap) {
    const cleanKey = key.split(' ')[0].replace(/\./g, '');
    if (cleanKey === clean) return positionMap[key];
  }
  return 'ATT'; // fallback
}

// Fixed: avoid duplicate names
function uniqueName(excludeSet) {
  let name;
  do {
    name = randPick(proPool);
    if (Math.random() < 0.15) name += ' ' + (Math.floor(Math.random() * 90) + 10);
  } while (excludeSet.has(name));
  return name;
}

/* --------------------------------------------------------------
   AI TEAM GENERATOR – FIXED POSITIONS
   -------------------------------------------------------------- */
function aiGenerateTeam(teamId, displayName) {
  const used = new Set();
  const players = [];

  // Force stars in correct ATT slot
  if (teamId === 'A') {
    players.push({ name: "C. Ronaldo", position: "CF", abilities: ["Shooting","Pace","Physical"], isSub: false });
    used.add("C. Ronaldo");
  }
  if (teamId === 'B') {
    players.push({ name: "L. Messi", position: "CAM", abilities: ["Dribbling","Passing","Shooting"], isSub: false });
    used.add("L. Messi");
  }

  // Fill exact starter slots: GK, 4 DEF, 4 MID, 2 ATT
  const slots = [
    'GK',
    'DEF','DEF','DEF','DEF',
    'MID','MID','MID','MID',
    'ATT','ATT'
  ];

  let attFilled = 0;
  slots.forEach(pos => {
    if (pos === 'ATT' && attFilled >= 2) return;
    if (pos === 'ATT' && players.some(p => p.position === 'CF' || p.position === 'CAM')) {
      attFilled++;
      return;
    }

    let candidate;
    do {
      candidate = uniqueName(used);
    } while (realPos(candidate) !== pos);

    used.add(candidate);
    const abil = shuffle([...abilitiesList]).slice(0, 3);
    players.push({ name: candidate, position: pos, abilities: abil, isSub: false });
    if (pos === 'ATT') attFilled++;
  });

  // Subs
  for (let s = 0; s < subsCount; s++) {
    const pos = randPick(['DEF', 'MID', 'ATT']);
    let name;
    do { name = uniqueName(used); } while (realPos(name) !== pos);
    used.add(name);
    const abil = shuffle([...abilitiesList]).slice(0, 3);
    players.push({ name, position: pos, abilities: abil, isSub: true });
  }

  state[teamId].name = displayName || state[teamId].name;
  state[teamId].players = players; // No shuffle — preserve order
  renderTeamList(teamId);
  checkStartReady();
}

/* --------------------------------------------------------------
   RENDER TEAM LIST
   -------------------------------------------------------------- */
function renderTeamList(teamId) {
  const cont = teamId === 'A' ? playersAContainer : playersBContainer;
  cont.innerHTML = '';
  const team = state[teamId];
  document.getElementById(teamId === 'A' ? 'teamATitle' : 'teamBTitle').textContent = team.name;

  team.players.forEach((p, idx) => {
    const isSub = idx >= starterCount;
    const slot = isSub ? `Sub ${idx - starterCount + 1}` : `Player ${idx + 1}`;
    const row = document.createElement('div');
    row.className = 'flex items-center justify-between bg-[#071413] p-2 rounded-md border border-gray-800';
    row.innerHTML = `
      <div>
        <div class="text-sm text-gray-300 font-semibold">${slot} — <span class="text-green-300">${p.name}</span></div>
        <div class="text-xs text-gray-400 mt-1">${p.position} · ${p.abilities.join(' · ')}</div>
      </div>
      <div class="text-xs text-gray-400">${p.isSub ? 'Sub' : 'Starter'}</div>
    `;
    cont.appendChild(row);
  });
}

/* --------------------------------------------------------------
   TICK HANDLERS
   -------------------------------------------------------------- */
let tickAOn = false, tickBOn = false;
tickA.addEventListener('click', () => {
  const nm = teamANameInput.value.trim() || 'Real Team A';
  tickAOn = !tickAOn;
  tickA.classList.toggle('tick-on', tickAOn);
  tickA.classList.toggle('bg-gray-900', !tickAOn);
  tickA.classList.toggle('text-white', tickAOn);
  if (tickAOn) { aiGenerateTeam('A', nm); teamANameInput.classList.add('border-green-500'); }
  else { state.A.players = []; renderTeamList('A'); teamANameInput.classList.remove('border-green-500'); }
});
tickB.addEventListener('click', () => {
  const nm = teamBNameInput.value.trim() || 'Real Team B';
  tickBOn = !tickBOn;
  tickB.classList.toggle('tick-on', tickBOn);
  tickB.classList.toggle('bg-gray-900', !tickBOn);
  tickB.classList.toggle('text-white', tickBOn);
  if (tickBOn) { aiGenerateTeam('B', nm); teamBNameInput.classList.add('border-green-500'); }
  else { state.B.players = []; renderTeamList('B'); teamBNameInput.classList.remove('border-green-500'); }
});
teamANameInput.addEventListener('input', () => { if (tickAOn && teamANameInput.value.trim()) aiGenerateTeam('A', teamANameInput.value.trim()); });
teamBNameInput.addEventListener('input', () => { if (tickBOn && teamBNameInput.value.trim()) aiGenerateTeam('B', teamBNameInput.value.trim()); });

/* --------------------------------------------------------------
   START-READY CHECK
   -------------------------------------------------------------- */
function checkStartReady() {
  const readyA = state.A.players.length >= starterCount + subsCount;
  const readyB = state.B.players.length >= starterCount + subsCount;
  startFlowBtn.disabled = !(readyA && readyB && tickAOn && tickBOn);
}
aiGenerateTeam = ((orig) => function(teamId, displayName) {
  orig.call(this, teamId, displayName);
  checkStartReady();
})(aiGenerateTeam);

/* --------------------------------------------------------------
   LOADING → MATCH START
   -------------------------------------------------------------- */
startFlowBtn.addEventListener('click', async () => {
  state.A.name = teamANameInput.value.trim() || state.A.name;
  state.B.name = teamBNameInput.value.trim() || state.B.name;

  loadingOverlay.classList.remove('hidden');
  loadingText.textContent = 'AI is locking lineups & preparing tactics…';
  await wait(600);
  for (let i = 5; i >= 0; i--) { countdownEl.textContent = i; await wait(1000); }
  loadingText.textContent = 'Matchmaking — generating tactical writeup...';
  await wait(1800);
  loadingOverlay.classList.add('hidden');
  openMatchModalAndStart();
});

/* --------------------------------------------------------------
   MATCH SIMULATION
   -------------------------------------------------------------- */
function openMatchModalAndStart() {
  modalTeamA.textContent = modalTeamAName.textContent = state.A.name;
  modalTeamB.textContent = modalTeamBName.textContent = state.B.name;
  state.sim.minute = state.sim.scoreA = state.sim.scoreB = 0;
  state.sim.possessionA = 50;
  scoreAEl.textContent = scoreBEl.textContent = '0';
  matchTimeEl.textContent = "0'";
  eventLog.innerHTML = modalCommentary.innerHTML = '';
  ['fouls','y','r'].forEach(k => { state.A.counters[k] = state.B.counters[k] = 0; });
  updateCountersUI();
  state.sim.minGoalGuaranteeApplied = false;

  drawPitchPlayers();
  matchModal.classList.remove('hidden');

  state.sim.running = true;
  state.sim.interval = setInterval(() => {
    if (!state.sim.running) return;
    state.sim.minute++;
    updateTimeUI(state.sim.minute);
    simulationTick(state.sim.minute);
    if (state.sim.minute >= state.sim.total + state.sim.extra) {
      clearInterval(state.sim.interval);
      finalizeMatch();
    }
  }, state.sim.minuteMs);
}
function updateTimeUI(min) {
  matchTimeEl.textContent = `${Math.min(min, state.sim.total + state.sim.extra)}'`;
}

/* --------------------------------------------------------------
   SIMULATION TICK
   -------------------------------------------------------------- */
function simulationTick(minute) {
  // Possession drift
  const delta = Math.floor(Math.random() * 5) - 2;
  state.sim.possessionA = Math.max(30, Math.min(70, state.sim.possessionA + delta));
  possessionInfo.textContent = `Possession — ${state.A.name} ${state.sim.possessionA}% · ${state.B.name} ${100-state.sim.possessionA}%`;

  // Attack
  const roll = Math.random();
  const threshA = 0.45 + (state.sim.possessionA - 50) / 200;
  const threshB = 0.45 + (50 - state.sim.possessionA) / 200;
  if (roll < threshA) resolveAttack('A', minute);
  else if (roll > 1 - threshB) resolveAttack('B', minute);
  else if (Math.random() < 0.3) pushCommentary(`${minute}' — Tense midfield battle.`);

  // Fouls
  if (Math.random() < 0.065) {
    const team = Math.random() < 0.5 ? 'A' : 'B';
    const player = pickPlayerName(team);
    const pill = findPlayerPill(team, player);
    state[team].counters.fouls++; updateCountersUI();
    pushEvent(`${player} (${state[team].name}) foul — ${minute}'`);

    // Penalty?
    if (Math.random() < 0.12) {
      setTimeout(() => resolvePenalty(team === 'A' ? 'B' : 'A', minute + 1), 600);
      return;
    }

    // Cards
    if (Math.random() < 0.28) {
      state[team].counters.y++; updateCountersUI();
      pushEvent(`Yellow card → ${player} (${minute}')`);
      if (pill) showCardIcon(pill, 'Y');
      if (Math.random() < 0.05) {
        state[team].counters.r++; updateCountersUI();
        pushEvent(`Red card! ${player} sent off (${minute}')`);
        if (pill) showCardIcon(pill, 'R');
      }
    }
  }

  // Min goal guarantee
  if (!state.sim.minGoalGuaranteeApplied && minute > 60 && state.sim.scoreA + state.sim.scoreB < 2) {
    state.sim.minGoalGuaranteeApplied = true;
    pushCommentary(`${minute}' — Crowd wants a goal!`);
    setTimeout(() => forceGoal(state.simpossessionA >= 50 ? 'A' : 'B', minute + 1), state.sim.minuteMs * 2);
  }
}

/* --------------------------------------------------------------
   ATTACK & PENALTY
   -------------------------------------------------------------- */
function resolveAttack(team, minute) {
  const attacker = pickPlayerName(team);
  pushCommentary(`${minute}' — ${attacker} attacks!`);
  setTimeout(() => {
    const roll = Math.random();
    if (roll < 0.28) { // Goal
      team === 'A' ? state.sim.scoreA++ : state.sim.scoreB++;
      scoreAEl.textContent = state.sim.scoreA; scoreBEl.textContent = state.sim.scoreB;
      pushEvent(`GOAL! ${attacker} — ${state[team].name} (${minute}')`);
      flashGoal(`${attacker} (${minute}')`);
      animateBallToHalf(team === 'A' ? 75 : 25, 50);
    } else if (roll < 0.55) {
      pushCommentary(`${minute}' — Keeper saves!`);
      animateBallToHalf(team === 'A' ? 60 : 40, 50);
    } else if (roll < 0.75) {
      pushCommentary(`${minute}' — Blocked!`);
      animateBallToHalf(team === 'A' ? 55 : 45, 50);
    } else {
      pushCommentary(`${minute}' — Wide.`);
      animateBallToHalf(team === 'A' ? 80 : 20, 50);
    }
  }, state.sim.minuteMs / 2);
}

function resolvePenalty(team, minute) {
  const scorer = pickPlayerName(team);
  const saved = Math.random() < 0.32;
  if (!saved) {
    team === 'A' ? state.sim.scoreA++ : state.sim.scoreB++;
    scoreAEl.textContent = state.sim.scoreA; scoreBEl.textContent = state.sim.scoreB;
    pushEvent(`PENALTY GOAL! ${scorer} (${minute}')`);
    flashGoal(`${scorer} (pen)`);
  } else {
    pushEvent(`PENALTY SAVED! ${scorer} (${minute}')`);
  }
}

/* --------------------------------------------------------------
   PLAYER PILL & CARD ICON
   -------------------------------------------------------------- */
function findPlayerPill(teamId, name) {
  return Array.from(pitchEl.querySelectorAll(`.player-pill[data-team="${teamId}"]`))
    .find(p => p.textContent.includes(name.split(' ')[0]));
}
function showCardIcon(pill, type) {
  const icon = document.createElement('div');
  icon.className = 'absolute -top-5 left-1/2 transform -translate-x-1/2 w-5 h-5 rounded-full flex items-center justify-center text-xs font-bold animate-pulse z-10';
  icon.style.backgroundColor = type === 'Y' ? '#facc15' : '#ef4444';
  icon.style.color = '#111';
  icon.textContent = type;
  pill.appendChild(icon);
  setTimeout(() => icon.remove(), 4000);
}

/* --------------------------------------------------------------
   PITCH & BALL
   -------------------------------------------------------------- */
function drawPitchPlayers() {
  pitchEl.innerHTML = '';
  const layoutA = formationPositions('A');
  const layoutB = formationPositions('B');

  state.A.players.slice(0, 11).forEach((p, i) => pitchEl.appendChild(createPlayerPill(p.name, 'A', i, layoutA[i])));
  state.B.players.slice(0, 11).forEach((p, i) => pitchEl.appendChild(createPlayerPill(p.name, 'B', i, layoutB[i])));

  setBallPosition(50, 50);
}
function formationPositions(team) {
  const left = team === 'A' ? 28 : 72;
  return [
    {x: left, y: 84}, // GK
    ...Array(4).fill().map((_, i) => ({x: left - 18 + i * 12, y: 68})), // DEF
    ...Array(4).fill().map((_, i) => ({x: left - 18 + i * 12, y: 48})), // MID
    {x: left - 6, y: 28}, {x: left + 6, y: 28} // ATT
  ];
}
function createPlayerPill(name, team, idx, pos) {
  const el = document.createElement('div');
  el.className = 'player-pill absolute text-xs font-semibold px-3 py-1 rounded-full flex items-center gap-2';
  el.dataset.team = team; el.dataset.idx = idx;
  el.style.left = pos.x + '%'; el.style.top = pos.y + '%';
  el.style.transform = 'translate(-50%,-50%)';
  el.style.cursor = 'grab';
  el.style.background = team === 'A' ? 'rgba(34,197,94,0.06)' : 'rgba(239,68,68,0.06)';
  el.style.border = team === 'A' ? '1px solid rgba(34,197,94,0.14)' : '1px solid rgba(239,68,68,0.12)';
  el.style.color = team === 'A' ? '#cffee0' : '#ffdede';
  el.innerHTML = `<span>${name.split(' ')[0]}</span>`;
  return el;
}
function setBallPosition(x, y) { ballEl.style.left = x + '%'; ballEl.style.top = y + '%'; }
function animateBallToHalf(x, y) {
  let sx = parseFloat(ballEl.style.left) || 50, sy = parseFloat(ballEl.style.top) || 50;
  let step = 0, steps = 12, dx = (x - sx) / steps, dy = (y - sy) / steps;
  const anim = setInterval(() => {
    if (++step >= steps) clearInterval(anim);
    setBallPosition(sx + dx * step, sy + dy * step);
  }, 30);
}

/* --------------------------------------------------------------
   FINALIZE & PENALTIES
   -------------------------------------------------------------- */
async function finalizeMatch() {
  pushEvent(`Full Time — ${state.A.name} ${state.sim.scoreA}–${state.sim.scoreB} ${state.B.name}`);
  if (state.sim.scoreA + state.sim.scoreB < 2) {
    const fav = state.sim.possessionA >= 50 ? 'A' : 'B';
    for (let i = 0; i < 2 - (state.sim.scoreA + state.sim.scoreB); i++) {
      forceGoal(fav, state.sim.total + i + 1); await wait(800);
    }
  }
  if (state.sim.scoreA === state.sim.scoreB) {
    pushCommentary('Draw — penalties!');
    await wait(1200); await runPenalties();
  } else {
    const winner = state.sim.scoreA > state.sim.scoreB ? state.A.name : state.B.name;
    pushEvent(`${winner} wins!`);
    flashGoal(`${winner} wins!`);
  }
  state.sim.running = false;
}

async function runPenalties() {
  const a = state.A.players.slice(0,5).map(p=>p.name);
  const b = state.B.players.slice(0,5).map(p=>p.name);
  let sa = 0, sb = 0;
  for (let i = 0; i < 5; i++) {
    if (Math.random() < 0.75) { sa++; pushEvent(`Scored — ${a[i]}`); flashGoal(`${a[i]} (pen)`); } else pushEvent(`Missed — ${a[i]}`);
    await wait(700);
    if (Math.random() < 0.75) { sb++; pushEvent(`Scored — ${b[i]}`); flashGoal(`${b[i]} (pen)`); } else pushEvent(`Missed — ${b[i]}`);
    await wait(700);
    if (sa > sb + (4-i) || sb > sa + (4-i)) break;
  }
  while (sa === sb) {
    const pa = pickPlayerName('A'), pb = pickPlayerName('B');
    if (Math.random() < 0.72) { sa++; pushEvent(`Sudden: ${pa} scores`); } else pushEvent(`Sudden: ${pa} misses`);
    await wait(700);
    if (Math.random() < 0.72) { sb++; pushEvent(`Sudden: ${pb} scores`); } else pushEvent(`Sudden: ${pb} misses`);
    await wait(700);
  }
  pushEvent(`Penalties: ${state.A.name} ${sa}–${sb} ${state.B.name}`);
  pushEvent(`${sa > sb ? state.A.name : state.B.name} wins on pens!`);
}

/* --------------------------------------------------------------
   UTILS
   -------------------------------------------------------------- */
function pickPlayerName(team) { return randPick(state[team].players.filter(p => p)).name; }
function forceGoal(team, min) { const s = pickPlayerName(team); (team==='A'?state.sim.scoreA++:state.sim.scoreB++); pushEvent(`GOAL! ${s} (${min}')`); flashGoal(s); scoreAEl.textContent=state.sim.scoreA; scoreBEl.textContent=state.sim.scoreB; }
function pushEvent(m) { const e = document.createElement('div'); e.className = 'mb-1 text-sm text-gray-300'; e.textContent = m; eventLog.prepend(e); pushCommentary(m); }
function pushCommentary(m) { const e = document.createElement('div'); e.className = 'mb-1 text-xs'; e.innerHTML = `<span class="text-gray-500">[${new Date().toTimeString().slice(0,5)}]</span> <span>${m}</span>`; modalCommentary.prepend(e); }
function flashGoal(t) { goalFlashHolder.innerHTML = `<div class="goal-flash">${t}</div>`; setTimeout(() => goalFlashHolder.innerHTML = '', 2000); }
function updateCountersUI() { mA_fouls.textContent = state.A.counters.fouls; mB_fouls.textContent = state.B.counters.fouls; mA_y.textContent = state.A.counters.y; mB_y.textContent = state.B.counters.y; mA_r.textContent = state.A.counters.r; mB_r.textContent = state.B.counters.r; }

/* --------------------------------------------------------------
   CONTROLS & DRAG
   -------------------------------------------------------------- */
pauseBtn.addEventListener('click', () => { state.sim.running = !state.sim.running; pauseBtn.textContent = state.sim.running ? 'Pause' : 'Resume'; });
ffBtn.addEventListener('click', () => { state.sim.minute += 6; updateTimeUI(state.sim.minute); });
closeModalBtn.addEventListener('click', () => { clearInterval(state.sim.interval); state.sim.running = false; matchModal.classList.add('hidden'); });
setInterval(() => { if (state.sim.running) randomBallMovement(); }, 1200);
function randomBallMovement() { const x = 50 + (state.sim.possessionA - 50) * 0.5; animateBallToHalf(x, 30 + Math.random() * 40); }

function enablePlayerDrag() {
  let drag = null, ox = 0, oy = 0;
  pitchEl.addEventListener('pointerdown', e => {
    const t = e.target.closest('.player-pill');
    if (!t) return;
    drag = t; t.setPointerCapture(e.pointerId);
    const r = pitchEl.getBoundingClientRect();
    const l = parseFloat(t.style.left), tp = parseFloat(t.style.top);
    ox = e.clientX - r.left - (l/100)*r.width;
    oy = e.clientY - r.top - (tp/100)*r.height;
    t.style.cursor = 'grabbing';
  });
  pitchEl.addEventListener('pointermove', e => {
    if (!drag) return;
    const r = pitchEl.getBoundingClientRect();
    let x = (e.clientX - r.left - ox) / r.width * 100;
    let y = (e.clientY - r.top - oy) / r.height * 100;
    x = Math.max(2, Math.min(98, x)); y = Math.max(2, Math.min(98, y));
    drag.style.left = x + '%'; drag.style.top = y + '%';
  });
  pitchEl.addEventListener('pointerup', e => { if (drag) { drag.releasePointerCapture(e.pointerId); drag.style.cursor = 'grab'; drag = null; } });
}
enablePlayerDrag();

setInterval(checkStartReady, 400);
window._state = state;
</script>

</body>
</html>
